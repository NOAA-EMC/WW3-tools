#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ProcSat_Altimeter.py

VERSION AND LAST UPDATE:
 v1.0  04/04/2022
 v1.1  07/18/2022
 v1.2  05/21/2023
 v1.3  10/11/2023
 v2.0  10/13/2023

PURPOSE:
 Script to process altimeter tracks. Two options are available:
 (1) It can collocate tracks into a lat/lon grid (structured or unstructured)
 a ww3 sample output
   or gridInfo.nc, generated by preprGridMask.py, must be entered)
 (2) Or keep the observation space as reference and produce averages
   along the track.
 This script uses confirguration inputs saved in ww3tools.yaml
  and the reading module wread.py
 A total of 15 satellite missions are listed below. The period of each
  altimeter can be verified at:
  https://www.sciencedirect.com/science/article/pii/S0273117721000594
  https://ars.els-cdn.com/content/image/1-s2.0-S0273117721000594-gr1_lrg.jpg

USAGE:
 This program processes one satellite mission per run, use -h to obtain detailed 
 information. This program assumes altimeter data has previously been downloaded, 
 see wfetchsatellite_AODN_Altimeter.sh for more information. 

 Many values are specified via a yaml file, such as if the target is model space 
 (tspace=1) or satellite space (tspace=2). Quality control options are also set
 via the yaml file. The path to staelite data and other arguments are set in the 
 yaml file. 

OUTPUT:
 netcdf and csv file in output directory specified in input yaml file. 

DEPENDENCIES:
 See setup.py and the imports below.
 AODN altimeter data previously downloaded (see wfetchsatellite_AODN_Altimeter.sh)
 Configure ww3tools.yaml as you prefer.

AUTHOR and DATE:
 04/04/2022: Ricardo M. Campos, first version.
 07/18/2022: Ricardo M. Campos, SENTINEL-3B included. Longitude standard checked.
 05/21/2023: Ricardo M. Campos, CFOSAT included. HsC-band removed. New dlim default
  obtained from https://doi.org/10.3390/rs15082203
 10/11/2023: Ricardo M. Campos, restructure to read config file with fixed inputs (.yaml),
  modularization, altimeter data reading sent to wread.py. Renamed gridSatGlobal_Altimeter.py
  to ProcSat_Altimeter.py
 10/13/2023: Ricardo M. Campos & Maryam Mohammadpour, include option to work on the
  observation space. Averages along track.

PERSON OF CONTACT:
 Ricardo M Campos: ricardo.campos@noaa.gov
 Maryam Mohammadpour: Ghazal.Mohammadpour@noaa.gov

"""

import numpy as np
from matplotlib.mlab import *
from pylab import *
import pandas as pd
import os
import netCDF4 as nc
import xarray as xr
import pyresample
from geopy.distance import geodesic
import time
import timeit
from datetime import datetime
from calendar import timegm
import wread
import sys
import warnings; warnings.filterwarnings("ignore")
import argparse

def along_track(AODN,atime,wconfig):
    '''
    The target is the observation space.
    Processing averages along-track, holding the obs space as reference.
    Inputs:
     (1) AODN pandas dataframe from wread.aodn_altimeter
     (2) time array (seconds since 1970)
     (3) wconfig dictionary, from wread.readconfig('ww3tools.yaml')
    Output: pandas dataframe containing: TIME (seconds since 1970), SAT_TIME (seconds since 1970),
      LATITUDE, LONGITUDE, WDEPTH, DISTCOAST, HS, HS_CAL, WSPD, WSPD_CAL
    Maryam Mohammadpour & Ricardo M. Campos
    '''

    # JASON3  112 minutes per revolution around the earth
    # https://www.ecmwf.int/en/newsletter/149/meteorology/use-radar-altimeter-products-ecmwf
    # https://www.nesdis.noaa.gov/current-satellite-missions/currently-flying/jason-3/jason-3-mission

    # spatial averages along track, using wconfig['dlim']
    i=0
    stime=[]; rstime=[]; slat=[]; slon=[]; swdepth=[]; swdistcoast=[]
    shs=[]; shscal=[]; swsp=[]; swspcal=[]
    for t in range(0,len(atime)):
        indt = np.where( abs(AODN['TIME'][:]-atime[t]) < wconfig['maxti'] )
        if np.size(indt)>1:
            indt=indt[0]
            # plot(AODN['LATITUDE'][indt],AODN['LONGITUDE'][indt],'.')
            lat=np.array(AODN['LATITUDE'][indt])
            lon=np.array(AODN['LONGITUDE'][indt]); lon[lon>360]=lon[lon>360]-360.
              
            # Coordinates of a point
            firstcoord = (lat[0], lon[0])
            segtrack = list(zip(lat, lon))
            # Calculate distances to reference coordinates
            distances = np.array([geodesic(firstcoord, ref_coords).meters for ref_coords in segtrack])
            # plot(distances,'.')
            segments = np.array(distances // wconfig['dlim']).astype('int')
            # print(' Total of '+repr(len(np.unique(segments)))+' segments')
            # 1h (+-30min) JASON3 2.850 Kms (487 records). Total of 82 segments of 35km
            for j in range(0,len(np.unique(segments))):
                indseg=np.where(segments==int(j))
                if np.size(indseg)>=1:
                    indseg=indseg[0]

                    stime = np.append(stime,atime[t])
                    rstime = np.append(rstime,np.nanmean(AODN['TIME'][indt[indseg]]))
                    slat = np.append(slat,np.nanmean(AODN['LATITUDE'][indt[indseg]]))
                    slon = np.append(slon,np.array(AODN['LONGITUDE'][indt[indseg]])[int(np.round(len(indseg)/2))]) # avoid problems with 360-0
                    swdepth = np.append(swdepth,np.nanmean(AODN['WDEPTH'][indt[indseg]]))
                    swdistcoast = np.append(swdistcoast,np.nanmean(AODN['DISTCOAST'][indt[indseg]]))
                    shs = np.append(shs,np.nanmean(AODN['HS'][indt[indseg]]))
                    shscal = np.append(shscal,np.nanmean(AODN['HS_CAL'][indt[indseg]]))
                    swsp = np.append(swsp,np.nanmean(AODN['WSPD'][indt[indseg]]))
                    swspcal = np.append(swspcal,np.nanmean(AODN['WSPD_CAL'][indt[indseg]]))
                    # print(repr(t)+" "+repr(i))
                    i=i+1
    swdepth = np.array(swdepth)
    swdistcoast = np.array(swdistcoast)
    shs = np.array(shs)
    swsp = np.array(swsp)

    if wconfig['qc']==0:
        indq = np.where( (stime>=adatemin) & (stime<=adatemax) )
    else:
        indq = np.where( (swdepth>=wconfig['mindepth']) & (swdistcoast>=wconfig['mindfc']) &
            (shs>wconfig['hsmin']) & (shs<wconfig['hsmax']) & (swsp>wconfig['wspmin']) & (swsp<wconfig['wspmax']) &
            (stime>=adatemin) & (stime<=adatemax) )

    if np.size(indq)>2:
        indq=indq[0]
        procaodn = {'TIME': stime[indq],'SAT_TIME': rstime[indq], 'LATITUDE': slat[indq], 'LONGITUDE': slon[indq],
            'WDEPTH': swdepth[indq], 'DISTCOAST': swdistcoast[indq],
            'HS': shs[indq], 'HS_CAL': shscal[indq],
            'WSPD': swsp[indq], 'WSPD_CAL': swspcal[indq]}

    else:
        procaodn = {'TIME': [],'SAT_TIME': [], 'LATITUDE': [], 'LONGITUDE': [],
            'WDEPTH': [], 'DISTCOAST': [],
            'HS': [], 'HS_CAL': [],
            'WSPD': [], 'WSPD_CAL': []}

    AODN_ALONGTRACK = pd.DataFrame(procaodn)
    return AODN_ALONGTRACK

# weight function for pyresample
def wf(pdist):
    a=(1 - pdist / (wconfig['dlim']+1))
    return (abs(a)+a)/2

def gridded(AODN,atime,wconfig):
    '''
    The target is the model space.
    Processing satellite collocation into grid points (structured or unstructured).
    Inputs:
     (1) AODN pandas dataframe from wread.aodn_altimeter
     (2) time array (seconds since 1970)
     (3) wconfig dictionary, from wread.readconfig('ww3tools.yaml')
    Output: pandas dataframe containing: TIME (seconds since 1970), SAT_TIME (seconds since 1970),
      LATITUDE, LONGITUDE, WDEPTH, DISTCOAST, HS, HS_CAL, WSPD, WSPD_CAL
    Ricardo M. Campos
    '''

    if str(wconfig['grid_info']).split('.')[-1] == 'grib2' or str(wconfig['grid_info']).split('.')[-1] == 'grb2': 
        # grib2 format
        ds = xr.open_dataset(wconfig['grid_info'], engine='cfgrib')
    else:
        # netcdf format
        ds = xr.open_dataset(wconfig['grid_info'])

    if ('latitude' in list(ds.coords)) or ('latitude' in list(ds.keys())):
        lat = np.array(ds['latitude'].values)
    elif ('LATITUDE' in list(ds.coords)) or ('LATITUDE' in list(ds.keys())):
        lat = np.array(ds['LATITUDE'].values)
    elif ('lat' in list(ds.coords)) or ('lat' in list(ds.keys())):
        lat = np.array(ds['lat'].values)
    elif ('LAT' in list(ds.coords)) or ('LAT' in list(ds.keys())):
        lat = np.array(ds['LAT'].values)

    if ('longitude' in list(ds.coords)) or ('longitude' in list(ds.keys())):
        lon = np.array(ds['longitude'].values)
    elif ('LONGITUDE' in list(ds.coords)) or ('LONGITUDE' in list(ds.keys())):
        lon = np.array(ds['LONGITUDE'].values)
    elif ('lon' in list(ds.coords)) or ('lon' in list(ds.keys())):
        lon = np.array(ds['lon'].values)
    elif ('LON' in list(ds.coords)) or ('LON' in list(ds.keys())):
        lon = np.array(ds['LON'].values)

    lon[lon>180]=lon[lon>180]-360.
    AODN['LONGITUDE'][AODN['LONGITUDE']>180.]=AODN['LONGITUDE'][AODN['LONGITUDE']>180.]-360.

    if wconfig['grid_format']==1:
        # Structured grid
        NEWLON, NEWLAT = meshgrid(lon,lat)
        NEWLON = np.reshape(NEWLON,(len(lon)*len(lat)))
        NEWLAT = np.reshape(NEWLAT,(len(lon)*len(lat)))
    else:
        # Unstructured grid
        NEWLON, NEWLAT = lon,lat

    if 'mask' in list(ds.keys()):
        mask=np.array(ds['mask'].values)
        if wconfig['grid_format']==1:
            mask = np.reshape(mask,(mask.shape[0]*mask.shape[1]))

        ind=np.where(mask>0)[0]; flatm = np.array(NEWLAT[ind]); flonm = np.array(NEWLON[ind])
        del ind
    else:
        flatm = np.array(NEWLAT); flonm = np.array(NEWLON)

    del NEWLON, NEWLAT
    targ_def = pyresample.geometry.SwathDefinition(lons=flonm,lats=flatm)

    slen=len(AODN); fctr=int(np.ceil(wconfig['dlim']/(np.nanmean(np.diff(np.unique(flatm)))*(10**8)))**2)
    ftime=np.double(np.zeros((slen*fctr),'d')); flat=np.zeros((slen*fctr),'f'); flon=np.zeros((slen*fctr),'f')
    fhsk=np.zeros((slen*fctr),'f'); stdhsk=np.zeros((slen*fctr),'f'); counthsk=np.zeros((slen*fctr),'f')
    fhskcal=np.zeros((slen*fctr),'f'); fwnd=np.zeros((slen*fctr),'f'); fwndcal=np.zeros((slen*fctr),'f')
    fwdepth=np.zeros((slen*fctr),'f'); fdfc=np.zeros((slen*fctr),'f');

    # into the regular grid with pyresample kd tree
    ii=0
    for t in range(0,len(atime)):
        indt = np.where( abs(AODN['TIME'].values[:]-atime[t]) < wconfig['maxti'] )
        if np.size(indt)>1:
            indt=indt[0]
            prlon=np.copy(AODN['LONGITUDE'].values[indt])
            orig_def = pyresample.geometry.SwathDefinition(lons=prlon, lats=AODN['LONGITUDE'].values[indt]); del prlon
            # By distance function wf
            auxfhsk, auxstdhsk, auxcounthsk = pyresample.kd_tree.resample_custom(orig_def,AODN['HS'].values[indt],targ_def,radius_of_influence=wconfig['dlim'],weight_funcs=wf,fill_value=0,with_uncert=True,nprocs=wconfig['npcs'])
            auxfhskcal = pyresample.kd_tree.resample_custom(orig_def,AODN['HS_CAL'].values[indt],targ_def,radius_of_influence=wconfig['dlim'],weight_funcs=wf,fill_value=0,nprocs=wconfig['npcs'])
            auxfwnd = pyresample.kd_tree.resample_custom(orig_def,AODN['WSPD'].values[indt],targ_def,radius_of_influence=wconfig['dlim'],weight_funcs=wf,fill_value=0,nprocs=wconfig['npcs'])
            auxfwndcal = pyresample.kd_tree.resample_custom(orig_def,AODN['WSPD_CAL'].values[indt],targ_def,radius_of_influence=wconfig['dlim'],weight_funcs=wf,fill_value=0,nprocs=wconfig['npcs'])
            auxfwdepth = pyresample.kd_tree.resample_nearest(orig_def,AODN['WDEPTH'].values[indt],targ_def,radius_of_influence=wconfig['dlim'],fill_value=0,nprocs=wconfig['npcs'])
            auxfdfc = pyresample.kd_tree.resample_nearest(orig_def,AODN['DISTCOAST'].values[indt],targ_def,radius_of_influence=wconfig['dlim'],fill_value=0,nprocs=wconfig['npcs'])
            # print('   - ok '+repr(t))
            indpqq = np.where( (auxfhskcal>0.01) & (auxfwnd>0.01) & (auxfhskcal<wconfig['hsmax']) & (auxfwnd<wconfig['wspmax']) &
                (auxstdhsk>0.001) & (auxcounthsk>0.) )

            if np.size(indpqq)>0:
                indpqq=indpqq[0]
                # allocate data into final array
                ftime[ii:ii+np.size(indpqq)] = np.array(np.zeros(np.size(indpqq),'d')+atime[t]).astype('double')
                flat[ii:ii+np.size(indpqq)] = np.array(flatm[indpqq]).astype('float')
                flon[ii:ii+np.size(indpqq)] = np.array(flonm[indpqq]).astype('float')
                fhsk[ii:ii+np.size(indpqq)] = np.array(auxfhsk[indpqq]).astype('float')
                fhskcal[ii:ii+np.size(indpqq)] = np.array(auxfhskcal[indpqq]).astype('float')
                fwnd[ii:ii+np.size(indpqq)] = np.array(auxfwnd[indpqq]).astype('float')
                fwndcal[ii:ii+np.size(indpqq)] = np.array(auxfwndcal[indpqq]).astype('float')
                fwdepth[ii:ii+np.size(indpqq)] = np.array(auxfwdepth[indpqq]).astype('float')
                fdfc[ii:ii+np.size(indpqq)] = np.array(auxfdfc[indpqq]).astype('float')
                ii=ii+len(indpqq)

            del auxfhsk, auxstdhsk, auxcounthsk, auxfhskcal, auxfwnd, auxfwndcal, indpqq
				
        del indt
        print('PyResample kdtree, hourly time, '+repr(t)+' of '+repr(atime.shape[0]))

    if wconfig['qc']==0:
        indf=np.where( (ftime>0.) & (fhsk>=0.0) )
    else:
        ind=np.where( (fhsk<wconfig['hsmin']) | (fhsk>wconfig['hsmax']) )
        if np.any(ind):
            fhsk[ind[0]]=np.nan; del ind

        ind=np.where( (fhskcal<wconfig['hsmin']) | (fhskcal>wconfig['hsmax']) )
        if np.any(ind):
            fhskcal[ind[0]]=np.nan; del ind

        ind=np.where( (fwnd<wconfig['wspmin']) | (fwnd>wconfig['wspmax']) )
        if np.any(ind):
            fwnd[ind[0]]=np.nan; del ind

        ind=np.where( (fwndcal<wconfig['wspmin']) | (fwndcal>wconfig['wspmax']) )
        if np.any(ind):
            fwndcal[ind[0]]=np.nan; del ind

        indf=np.where( (ftime>0.) & (fhsk>=wconfig['hsmin']) & (fwdepth>=wconfig['mindepth']) & (fdfc>=wconfig['mindfc']) )

    if np.size(indf)>0:
        indf=indf[0]
        ftime=np.array(ftime[indf]).astype('double')
        flat=np.array(flat[indf]); flon=np.array(flon[indf])
        fwdepth=np.array(fwdepth[indf]); fdfc=np.array(fdfc[indf])
        fhsk=np.array(fhsk[indf]); fhskcal=np.array(fhskcal[indf])
        fwnd=np.array(fwnd[indf]); fwndcal=np.array(fwndcal[indf])

        procaodn = {'TIME': ftime,'SAT_TIME': ftime, 'LATITUDE': flat, 'LONGITUDE': flon,
            'WDEPTH': fwdepth, 'DISTCOAST': fdfc,
            'HS': fhsk, 'HS_CAL': fhskcal,
            'WSPD': fwnd, 'WSPD_CAL': fwndcal}

    else:
        procaodn = {'TIME': [],'SAT_TIME': [], 'LATITUDE': [], 'LONGITUDE': [],
            'WDEPTH': [], 'DISTCOAST': [],
            'HS': [], 'HS_CAL': [],
            'WSPD': [], 'WSPD_CAL': []}

    print(' '); print(' gridded() Competed. Array Size '+str(np.size(indf))); print(' ')
    AODN_GRIDDED = pd.DataFrame(procaodn)
    return AODN_GRIDDED


def savesat(AODN,wconfig,altsel):
    '''
    Save AODN processed data (along-track or gridded)
    Inputs:
     (1) AODN pandas dataframe
     (2) wconfig dictionary, from wread.readconfig('ww3tools.yaml')
     (3) altimeter name
    Output: netcdf and csv (if array is not huge) saved in the output path
     defined in ww3tools.yaml
    '''

    if wconfig['tspace']==1:
        smethod="Gridded"
        hmsg="AODN Altimeter data on model grid."
    elif wconfig['tspace']==2:
        smethod="AlongTrack"
        hmsg="AODN Altimeter data processed along track."

    datein = datetime.utcfromtimestamp(AODN['TIME'].iloc[0]).strftime('%Y%m%d%H')
    datefin = datetime.utcfromtimestamp(AODN['TIME'].iloc[-1]).strftime('%Y%m%d%H')

    #create path_out directory if it does not exist: 
    if not os.path.isdir(wconfig['path_out']):
        os.makedirs(wconfig['path_out'])

    fname=wconfig['path_out']+"Altimeter"+smethod+"_"+wconfig['ftag']+"_"+altsel+"_"+datein+"to"+datefin

    # Save netcdf
    ncfile = nc.Dataset(fname+".nc", "w", format=wconfig['fnetcdf']) 
    ncfile.history=hmsg
    # create  dimensions.
    ncfile.createDimension('time' , len(AODN['TIME']))
    ncfile.createDimension('sname' , 1 )
    # create variables.
    vflat = ncfile.createVariable('latitude',np.dtype('float32').char,('time'))
    vflon = ncfile.createVariable('longitude',np.dtype('float32').char,('time'))
    vft = ncfile.createVariable('time',np.dtype('float64').char,('time'))
    vfst = ncfile.createVariable('sat_time',np.dtype('float64').char,('time'))
    vsname = ncfile.createVariable('sat_name',dtype('a25'),('sname'))
    vfhs = ncfile.createVariable('hs',np.dtype('float32').char,('time'))
    vfhscal = ncfile.createVariable('hs_cal',np.dtype('float32').char,('time'))
    vfwnd = ncfile.createVariable('wsp',np.dtype('float32').char,('time'))
    vfwndcal = ncfile.createVariable('wsp_cal',np.dtype('float32').char,('time'))
    # Assign units
    vft.units = 'seconds since 1970-01-01 00:00:00'
    vfst.units = 'seconds since 1970-01-01 00:00:00'
    vflat.units = 'degrees_north' ; vflon.units = 'degrees_east'
    vfwnd.units = 'm/s' ; vfwndcal.units = 'm/s'
    vfhs.units = 'm'; vfhscal.units = 'm'
    # Add Details
    vfhs.long_name = 'sigificant_wave_height'
    vfhscal.long_name = 'calibrated_sigificant_wave_height'
    vfwnd.long_name = 'wind_speed'
    vfwndcal.long_name = 'calibrated_wind_speed'

    #Add additional variables that are used in creation of the file
    vdlim = ncfile.createVariable('dlim',np.dtype('int16'),('sname'))
    vdlim.long_name = 'MaxDistForAveraging'
    vdlim.units = 'm'
    vdlim[:] = np.array(wconfig['dlim'])

    vmaxti = ncfile.createVariable('maxti',np.dtype('int16'),('sname'))
    vmaxti.long_name = 'MaxTimeDistForAveraging'
    vmaxti.units = 'seconds'
    vmaxti[:] = np.array(wconfig['maxti'])

    vtstep = ncfile.createVariable('tstep',np.dtype('int16'),('sname'))
    vtstep.long_name = 'time_step'
    vtstep.units = 'seconds'
    vtstep[:] = np.array(time_step)

    vqcvar = ncfile.createVariable('qc_var',np.dtype('int16'),('sname'))
    vqcvar.long_name = 'QCvar'
    vqcvar[:] = np.array(wconfig['qc'])
    if wconfig['qc']!=0:
        vmindepth = ncfile.createVariable('qc_mindepth',np.dtype('float32'),('sname'))
        vmindepth.long_name = 'Minimum_Depth_QCvar'
        vmindepth.units = 'm'
        vmindepth[:] = np.array(wconfig['mindepth'])

        vmindist = ncfile.createVariable('qc_mindist',np.dtype('float32'),('sname'))
        vmindist.long_name = 'Minimum_Distance_From_Coast_QCvar'
        vmindist.units = 'm'
        vmindist[:] = np.array(wconfig['mindfc'])

        vhsmin = ncfile.createVariable('qc_hsmin',np.dtype('float32'),('sname'))
        vhsmin.long_name = 'Minimum_HS_QCvar'
        vhsmin.units = 'm'
        vhsmin[:] = np.array(wconfig['hsmin'])

        vhsmax = ncfile.createVariable('qc_hsmax',np.dtype('float32'),('sname'))
        vhsmax.long_name = 'Maximum_HS_QCvar'
        vhsmax.units = 'm'
        vhsmax[:] = np.array(wconfig['hsmax'])

        vwspmin = ncfile.createVariable('qc_wspmin',np.dtype('float32'),('sname'))
        vwspmin.long_name = 'Minimum_WindSpeed_QCvar'
        vwspmin.units = 'm/s'
        vwspmin[:] = np.array(wconfig['wspmin'])

        vwspmax = ncfile.createVariable('qc_wspmax',np.dtype('float32'),('sname'))
        vwspmax.long_name = 'Maximum_WindSpeed_QCvar'
        vwspmax.units = 'm/s'
        vwspmax[:] = np.array(wconfig['wspmax'])

    # Allocate Data
    vsname[:] = np.array(altsel).astype('str')
    vflat[:] = np.array(AODN['LATITUDE']); vflon[:] = np.array(AODN['LONGITUDE'])
    vft[:] = np.array(AODN['TIME']).astype('double'); vfst[:] = np.array(AODN['SAT_TIME']).astype('double'); 
    vfhs[:] = np.array(AODN['HS']); vfhscal[:] = np.array(AODN['HS_CAL'])
    vfwnd[:] = np.array(AODN['WSPD']); vfwndcal[:] = np.array(AODN['WSPD_CAL'])
    ncfile.close()
    print(' ')
    print("netcdf output: "+fname+".nc")

    del vft, vfst, vflat, vflon, vfhs,vfhscal, vfwnd, vfwndcal

    if len(AODN['TIME'])<10**8 :
        AODN.iloc[:, 2:] = AODN.iloc[:, 2:].round(3)
        AODN.to_csv(fname+".csv", index=False)

    print("text file output: "+fname+".csv")


if __name__ == "__main__":

    # start time
    start = timeit.default_timer()

    ap = argparse.ArgumentParser()
    ap.add_argument('-s', '--satelite', help="Satelite Name, one of JASON3,JASON2,CRYOSAT2,JASON1,HY2,SARAL,SENTINEL3A,ENVISAT,ERS1,ERS2,GEOSAT,GFO,TOPEX,SENTINEL3B,CFOSAT",required=True) 
    ap.add_argument('-i', '--initdate', help="Initial Date (YYYYMMDDHH)", default='1985010100')
    ap.add_argument('-e', '--enddate', help="Final Date (YYYYMMDDHH)", default=datetime.utcnow().strftime("%Y%m%d%H"))
    ap.add_argument('-t', '--timestep', help="time step (in seconds) to build the final time array (regular)", default=float(3600.))
    ap.add_argument('-y', '--yaml', help="WW3 tools yaml file", default='ww3tools.yaml') 

    MyArgs = ap.parse_args()
    
    # WW3-tools configuration file
    wconfig=wread.readconfig(MyArgs.yaml)

    # Set Satelite 
    altsel = MyArgs.satelite
    # Set date interval
    datemin = MyArgs.initdate
    datemax = MyArgs.enddate
    # Default time step (in seconds) to build the final time array (regular)
    time_step=np.double(MyArgs.timestep)
    
    # read and organize AODN altimeter data for the mission and domain of interest
    AODN = wread.aodn_altimeter(altsel,wconfig,datemin,datemax)
    # AODN.to_csv(wconfig['path_out']+"AODN_altimeterSelection_"+datemin+"to"+datemax+".csv", index=False)
    if AODN.empty:
        print(f"No data available for {altsel} satellite in the specified time range: {datemin} to {datemax}.")
        print("Please enter a time range covered by the satellite.")
        sys.exit(1)

    # date interval in seconds since 1970, user selection
    adatemin= np.double(timegm( time.strptime(datemin, '%Y%m%d%H')))
    adatemax= np.double(timegm( time.strptime(datemax, '%Y%m%d%H')))
    atime = np.array(np.arange(adatemin,adatemax+1.,time_step)).astype('double')

    if wconfig['tspace']==2:
        AODN_ALONGTRACK = along_track(AODN,atime,wconfig)
        if not AODN_ALONGTRACK.empty:
            savesat(AODN_ALONGTRACK,wconfig,altsel)
        else:
            print(f"No processed data available for {altsel} in the specified time range after processing.")
            sys.exit(1)

    elif wconfig['tspace']==1:
        AODN_GRID = gridded(AODN,atime,wconfig)
        savesat(AODN_GRID,wconfig,altsel)

    stop = timeit.default_timer()
    print('ProcSat_Altimeter.py  successfully completed in '+repr(int(round(stop - start,0)))+' seconds. See the output at '+wconfig['path_out'])

