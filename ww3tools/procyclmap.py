#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
procyclmap.py

VERSION AND LAST UPDATE:
 v1.0  04/04/2022

PURPOSE:
 This script creates a map with cyclone information, using the gridInfo 
  (generated by preprGridMask.py) and cyclone tracks from IBTracks.
 The cyclone information is provided on the grid gridInfo.nc, where
  lat/lon is taken. This scripts is run for one year (input argument)
  and the output netcdf file has 3-hourly resolution.

USAGE:
 It reads an argument with the year of interest.
 The file ibtracs.since1980.list.v04r00.csv must be saved (or symbolic link)
 Example:
  python3 procyclmap.py 2010
  nohup python3 procyclmap.py 2019 >> nohup_cyclmap_2019.out 2>&1 &

OUTPUT:
 netcdf file with integers where, for each grid point and time:
 0(no cyclone); 1(Missing,conflicting,or not reported); 
 2(disturbance); 3(extratropical); 4(subtropical storm/cyclone); 
 5(tropical storm/cyclone)
 located at the grid informed by gridInfo.nc, for one year 
 (input argument), with 3-hourly results.

DEPENDENCIES:
 See setup.py and the imports below.
 gridInfo.nc generated by preprGridMask.py
 IBTRACKS V4 data. It can be downloaded at
  https://www.ncei.noaa.gov/data/international-best-track-archive-for-climate-stewardship-ibtracs/v04r00/access/csv/
  https://www.ncdc.noaa.gov/ibtracs/index.php?name=bib

AUTHOR and DATE:
 04/04/2022: Ricardo M. Campos, first version.

PERSON OF CONTACT:
 Ricardo M Campos: ricardo.campos@noaa.gov

"""

import pylab
from pylab import *
from matplotlib.mlab import *
import geopy.distance
import netCDF4 as nc
import numpy as np
import sys
import time
from calendar import timegm
import matplotlib.pyplot as plt
import pandas as pd
import warnings; warnings.filterwarnings("ignore")
fnetcdf="NETCDF4_CLASSIC"

year=int(sys.argv[1]) # input argument
datelim=str(year)+'123123'
# 3-hourly data, if you want to change the time resolution, please edit the next line.
ftime = np.array(np.arange(float(timegm( time.strptime(str(year)+'010100', '%Y%m%d%H') )),float(timegm( time.strptime(datelim, '%Y%m%d%H') ))+1,3.*3600.)).astype('double')
# Cyclone radius (km) for tropical cyclones, followed by its transition to extratropical 
# https://journals.ametsoc.org/view/journals/clim/29/8/jcli-d-15-0731.1.xml
# https://www.nhc.noaa.gov/pdf/carrasco-etal-wf2014.pdf
tcr=500.; etr=1000.

# READ mask
f=nc.Dataset('gridInfo.nc')
latm=f.variables['latitude'][:]; lonm=f.variables['longitude'][:]
maskm=f.variables['mask'][:,:];
f.close(); del f
# -------------

# --- Read Tracks -----
# READ IBTRACKS V4 https://www.ncei.noaa.gov/data/international-best-track-archive-for-climate-stewardship-ibtracs/v04r00/access/csv/
# https://www.ncdc.noaa.gov/ibtracs/index.php?name=bib
# http://www.euro4m.eu/Presentations_ACRE/Diamond_acre_11_IBTrACS.pdf
# https://www.fgdl.org/metadata/fgdl_html/tropc_dec13.htm
# Storm nature: TS - storm is tropical SS - Subtropical ET - Extratropical DS - Disturbance MX - Mix of conflicting reports NR - Not Reported MM - Missing
# pick TS,SS,DS,ET,MX/NR . Exclude MX,NR

ity=[];itm=[];itd=[];ith=[];ilat=[];ilon=[];inat=[]
# North Atlantic
dfibtr = pd.read_csv('ibtracs.since1980.list.v04r00.csv', header=[0,1])
inat=np.append(inat,dfibtr.values[:,7]); ilat=np.append(ilat,dfibtr.values[:,8]); ilon=np.append(ilon,dfibtr.values[:,9])
ity=np.append(ity,np.array(pd.Series(dfibtr['ISO_TIME'].values.flatten()).str.slice(0,4)).astype('int'))
itm=np.append(itm,np.array(pd.Series(dfibtr['ISO_TIME'].values.flatten()).str.slice(5,7)).astype('int'))
itd=np.append(itd,np.array(pd.Series(dfibtr['ISO_TIME'].values.flatten()).str.slice(8,10)).astype('int'))
ith=np.append(ith,np.array(pd.Series(dfibtr['ISO_TIME'].values.flatten()).str.slice(11,13)).astype('int'))
print('Ibtracks ok'); del dfibtr
ind=np.where(ity>=2000)
ity=np.copy(ity[ind[0]]);itm=np.copy(itm[ind[0]]); itd=np.copy(itd[ind[0]]); ith=np.copy(ith[ind[0]])
ilat=np.copy(ilat[ind[0]]);ilon=np.copy(ilon[ind[0]]);inat=np.copy(inat[ind[0]])
del ind
ilon[ilon<0]=ilon[ilon<0]+360.

# -----------
# Organize time
ind=np.where(ity==np.float(year))[0]; inat=np.copy(np.array(inat[ind]))
ilat=np.copy(np.array(ilat[ind]).astype('int')); ilon=np.copy(np.array(ilon[ind]).astype('int'))
ity=np.copy(np.array(ity[ind]).astype('int')); itm=np.copy(np.array(itm[ind]).astype('int'))
itd=np.copy(np.array(itd[ind]).astype('int')); ith=np.copy(np.array(ith[ind]).astype('int'))
del ind; it=[]
for i in range(0,np.size(ity)):
	it = np.append(it,np.array(timegm( time.strptime(repr(ity[i])+str(itm[i]).zfill(2)+str(itd[i]).zfill(2)+str(ith[i]).zfill(2), '%Y%m%d%H') )).astype('double'))

# -----------

# resolution
gres=np.diff(latm).mean()
# displacement for the cyclone area
dglat = int(np.ceil(((etr/100.)+1.0)/gres))
# Final array of mask
cmask=np.zeros((ftime.shape[0],maskm.shape[0],maskm.shape[1]),'i')
# loop through all times
for t in range(0,ftime.shape[0]):
	cmask[t,:,:]=cmask[t,:,:]*maskm
	# search for cyclones on that time, using +- 1 hour
	# Tropical cyclones
	indt = np.where( (it>=(ftime[t]-5401)) & (it<=(ftime[t]+5401)) )
	if np.size(indt)>0.:
		# if cyclones found (one or more), loop through cyclones
		indt=np.array(indt[0]).astype('int')
		for i in range(0,indt.shape[0]):
			# center of the cyclone
			indilat=np.where( np.abs(latm-ilat[indt[i]])==np.min(np.abs(latm-ilat[indt[i]])) )[0][0]
			indilon=np.where( np.abs(lonm-ilon[indt[i]])==np.min(np.abs(lonm-ilon[indt[i]])) )[0][0]

			# Index of grid points whithin the cyclone
			rlat=np.array(np.where( (latm>=latm[indilat]-gres*dglat) & (latm<=latm[indilat]+gres*dglat) )[0]).astype('int')
			dglon = int(np.ceil((etr/(90./(1/np.cos(np.abs(latm)[int(np.round(np.mean(rlat)))]*(pi/180)))))/gres))
			rlon=np.array(np.where( (lonm>=lonm[indilon]-gres*dglon) & (lonm<=lonm[indilon]+gres*dglon) )[0]).astype('int')
			if np.abs(ilat[indt[i]])<40.:
				etrl= tcr + np.max([0,np.abs(ilat[indt[i]])-20.])*(etr-tcr)/20.
			else:
				etrl=etr

			for j in range(0,rlat.shape[0]):
				for k in range(0,rlon.shape[0]):
					cdist=np.float(geopy.distance.great_circle((latm[rlat[j]],lonm[rlon[k]]), (latm[indilat],lonm[indilon]) ).kilometers)
					if (cdist<=etrl) and (maskm[rlat[j],rlon[k]]>=0.):
						if inat[indt[i]]=='TS':
							cmask[t,rlat[j],rlon[k]]=int(5)
						elif inat[indt[i]]=='SS':
							cmask[t,rlat[j],rlon[k]]=int(4)
						elif inat[indt[i]]=='ET':
							cmask[t,rlat[j],rlon[k]]=int(3)
						elif inat[indt[i]]=='DS':
							cmask[t,rlat[j],rlon[k]]=int(2)
						else:
							cmask[t,rlat[j],rlon[k]]=int(1)

					del cdist

			del rlat,rlon,indilat,indilon

		del indt

	print('  t : '+repr(t)+'   of '+repr(ftime.shape[0]))

# Save netcdf
cmask[cmask<0.]=-1
ncfile = nc.Dataset('CycloneMap_'+repr(year)+'.nc', "w", format=fnetcdf) 
ncfile.history='Cyclone Map using IBtracks cyclone tracks, with same grid resolution as GEFSv12 winds.'
ncfile.info='IDs: 0(no cyclone); 1(Missing,conflicting,or not reported); 2(disturbance); 3(extratropical); 4(subtropical storm/cyclone); 5(tropical storm/cyclone)'
# create  dimensions.
ncfile.createDimension('time', ftime.shape[0])
ncfile.createDimension('lat', latm.shape[0])
ncfile.createDimension('lon', lonm.shape[0])
# Model results
vcmap = ncfile.createVariable('cmap',np.dtype('int32'),('time','lat','lon'))
#
vt = ncfile.createVariable('time',np.dtype('float64'),('time'))
vlat = ncfile.createVariable('lat',np.dtype('float32'),('lat',))
vlon = ncfile.createVariable('lon',np.dtype('float32'),('lon'))
# Units
vlat.units = 'degrees_north' ; vlon.units = 'degrees_east'
vt.units = "seconds since 1970-01-01 00:00:00.0 0:00"
# Allocate Data
vt[:] = ftime[:]; vlat[:] = latm[:]; vlon[:] = lonm[:]
vcmap[:,:,:] = cmask
ncfile.close()
print('netcdf ok ')

