#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
modelSat_collocation.py

VERSION AND LAST UPDATE:
 v1.0  05/10/2022

PURPOSE:
 Collocation/pairing ww3 field output results with altimeters.
 Matchups of ww3 results and satellite data are generated, for the same
  points (lat/lon) and time.
 Additional information is collocated as well, such as water depth,
  distance to the nearest coast, ocean names, forecast zones, and
  satellite names.

USAGE:
 This code is designed for ww3 simulations with one continuous time
  dimension only, and not forecast with consecutive cycles or ensembles.
 Four information must be entered by the user:
 - GridInfo netcdf file (generated by prepGridMask.py), see and edit 
   gridinfo variable below, with path+name.
 - Cyclone map netcdf file (generated by procyclmap.py), see and edit
   cyclonemap variable below, with path+name. In case there are multiple
   years in separated files, you can enter CycloneMap_*.nc and all the
   files/years in that directory will be properly read.
 - Altimeter Gridded netcdf files (generated by gridSatGlobal_Altimeter.py)
   that must be written into a list named satlist.txt. Each line containing
   one satellite mission.
 - WAVEWATCHIII netcdf field outputs, also saved in a list ww3list.txt
 It is important to mention that the grid points of WAVEWATCHIII results
  must be the same as GridInfo, Cyclone map, and gridded satellite data,
  so it is recommended to run the following codes to prepare that:
  prepGridMask.py, procyclmap.py, and gridSatGlobal_Altimeter.py.

OUTPUT:
 netcdf file WW3.Altimeter_*.nc containing the matchups of WAVEWATCHIII
  and altimeter data for the same positions, plus the water depth, 
  distance to the nearest coast, ocean names, forecast zones, 
  and satellite names.

DEPENDENCIES:
 See dependencies.py and the imports below.
 GridInfo netcdf file (generated by prepGridMask.py)
 Cyclone map netcdf file (generated by procyclmap.py)
 Altimeter Gridded netcdf files (generated by gridSatGlobal_Altimeter.py)
 WAVEWATCHIII netcdf field outputs

AUTHOR and DATE:
 05/10/2022: Ricardo M. Campos, first version.

PERSON OF CONTACT:
 Ricardo M Campos: ricardo.campos@noaa.gov

"""
import numpy as np
from matplotlib.mlab import *
from pylab import *
import xarray as xr
import netCDF4 as nc
import time
from time import strptime
from calendar import timegm
import warnings; warnings.filterwarnings("ignore")
# netcdf format
fnetcdf="NETCDF4"

# Grid Info File
gridinfo='/work/noaa/marine/ricardo.campos/work/analysis/1preproc/mask/GFS10mxt/gridInfo_GFS10mxt.nc'
# Cyclone Map file (or files). You can enter CycloneMap_*.nc and all the files/years in that directory will be read.
cyclonemap='/work/noaa/marine/ricardo.campos/work/analysis/1preproc/cyclonemap/GFS10mxt/CycloneMap_2021.nc'

# READ mask Grid Info
f=nc.Dataset(gridinfo)
mlat=np.array(f.variables['latitude'][:]); mlon=np.array(f.variables['longitude'][:])
mask=f.variables['mask'][:,:]; distcoast=f.variables['distcoast'][:,:]; depth=f.variables['depth'][:,:]
oni=f.variables['GlobalOceansSeas'][:,:]; hsmz=f.variables['HighSeasMarineZones'][:,:]
ocnames=f.variables['names_GlobalOceansSeas'][:]; hsmznames=f.variables['names_HighSeasMarineZones'][:] 
f.close(); del f
print(" "); print(" GridInfo Ok.")
# -------------

# READ Cyclone map
fcy=nc.MFDataset(cyclonemap, aggdim='time')
clat=np.array(fcy.variables['lat'][:]); clon=np.array(fcy.variables['lon'][:])
cmap=fcy.variables['cmap']; ctime=fcy.variables['time'][:]
cinfo=np.str(fcy.info); cinfo=np.array(np.str(cinfo).split(':')[1].split(';'))

if np.array_equal(clat,mlat)==True & np.array_equal(clon,mlon)==True: 
	print(" CycloneMap Ok.")
else:
	sys.exit(' Error: Cyclone grid and Mask grid are different.')

# -------------

# READ list Gridded Satellites
try:
	slist=np.loadtxt('satlist.txt',dtype=str)
	if size(slist)==1:
		slist=[slist]
	# criar id satellite.
except:
	sys.exit(' Could not open the list with satellite information AltimeterGridded_*.nc, resulted from gridSatGlobal_Altimeter.py')
else:
	sdname=np.array(['JASON3','JASON2','CRYOSAT2','JASON1','HY2','SARAL','SENTINEL3A','ENVISAT','ERS1','ERS2','GEOSAT','GFO','TOPEX'])
	slat=[];slon=[];swnd=[];shs=[];stime=[];sid=[]
	for i in range(0,size(slist)):
		f=nc.Dataset(slist[i])
		slat=np.append(slat,np.array(f.variables['latitude'][:]))
		slon=np.append(slon,np.array(f.variables['longitude'][:]))
		swnd=np.append(swnd,np.array(f.variables['wndcal'][:]))
		shs=np.append(shs,np.array(f.variables['hskcal'][:]))
		stime=np.append(stime,np.array(f.variables['stime'][:]))
		f.close(); del f
		sid=np.append(sid,np.zeros(stime.shape[0],'int')+np.int(np.where(np.str(slist[i]).split('_')[1].split('.')[0] == sdname)[0][0]))

print(" Satellite Data Ok.")

# READ list WW3 files
try:
	wlist=np.loadtxt('ww3list.txt',dtype=str)
	if size(wlist)==1:
		wlist=[wlist]
except:
	sys.exit(' Could not open the list with WAVEWATCHIII outputs.')

else:
	print(" Read list of WW3 files Ok. Start building the matchups model/satellite ...")
	fwhs=np.zeros(stime.shape[0],'f')*np.nan; fwwnd=np.zeros(stime.shape[0],'f')*np.nan
	fshs=np.zeros(stime.shape[0],'f')*np.nan; fswnd=np.zeros(stime.shape[0],'f')*np.nan; fsid=np.zeros(stime.shape[0],'f')*np.nan
	flat=np.zeros(stime.shape[0],'f')*np.nan; flon=np.zeros(stime.shape[0],'f')*np.nan; fcmap=np.zeros(stime.shape[0],'f')*np.nan
	ftime=np.zeros(stime.shape[0],'d')*np.nan; fmonth=np.zeros(stime.shape[0],'i')*np.nan
	fdistcoast=np.zeros(stime.shape[0],'f')*np.nan; fdepth=np.zeros(stime.shape[0],'f')*np.nan; foni=np.zeros(stime.shape[0],'i')*np.nan; fhsmz=np.zeros(stime.shape[0],'i')*np.nan
	c=0
	for i in range(0,size(wlist)):
		try:
			# sequence of ww3 files cannot have overlapped time periods, i.e.,
			#  the last time step of previous file must come before the first time step of the next file.
			f=nc.Dataset(np.str(wlist[i]))
		except:
			print(" Error: Cannot open "+np.str(wlist[i]))
		else:
			wlon=np.array(f.variables['longitude'][:]); wlat=np.array(f.variables['latitude'][:])
			if np.array_equal(wlat,mlat)==False | np.array_equal(wlon,mlon)==False: 
				sys.exit(' Error: Cyclone grid and Mask grid are different.')

			wtime = np.array(f.variables['time'][:]*24*3600 + timegm( strptime(np.str(f.variables['time'].units).split(' ')[2][0:4]+'01010000', '%Y%m%d%H%M') )).astype('double')
			# Coincident/Matching Time (model/satellite)
			aux=np.intersect1d(wtime, stime, assume_unique=False, return_indices=True)
			indtauxw=np.array(aux[1]).astype('int'); del aux
			# loop through ww3 time steps
			for t in range(0,size(indtauxw)):
	
				# search for cyclone time index and cyclone map
				indc=np.where(np.abs(ctime-wtime[indtauxw[t]])<5400.)
				if size(indc)>0:
					acmap=np.array(cmap[indc[0][0],:,:])
					del indc
				else:
					acmap=np.zeros((mlat.shape[0],mlon.shape[0]),'f')*np.nan
					print(' Warning: No cyclone information for this time step: '+repr(t))

				inds=np.where(np.abs(stime-wtime[indtauxw[t]])<1800.)
				if size(inds)>0:
					# WW3 Significant Wave Height
					whs = np.array(f.variables['hs'][indtauxw[t],:,:])
					# WW3 Wind Speed
					wwnd = np.array(np.sqrt( f.variables['uwnd'][indtauxw[t],:,:]**2 + f.variables['vwnd'][indtauxw[t],:,:]**2 ))
					# 'fp', 'dp', 'phs0', 'phs1', 'phs2', 'ptp0', 'ptp1', 'ptp2', 'pdir0', 'pdir1', 'pdir2'
					# loop through the gridded satellite data for that selected time matching WW3 time.
					for j in range(0,size(inds)):
						# indexes and lat/lon for the WW3 grid point
						indgplat = np.where( abs(mlat-slat[inds[0][j]])==abs(mlat-slat[inds[0][j]]).min() )[0][0]
						indgplon = np.where( abs(mlon-slon[inds[0][j]])==abs(mlon-slon[inds[0][j]]).min() )[0][0]
						if (mask[indgplat,indgplon]==1) & (distcoast[indgplat,indgplon]>0.) & (depth[indgplat,indgplon]>0.):
							# model
							fwhs[c]=whs[indgplat,indgplon]; fwwnd[c]=wwnd[indgplat,indgplon]
							# satellite
							fshs[c]=shs[inds[0][j]]; fswnd[c]=swnd[inds[0][j]]; fsid[c]=sid[inds[0][j]]
							# position
							flat[c]=mlat[indgplat]; flon[c]=mlon[indgplon]
							# grid info
							fdistcoast[c]=distcoast[indgplat,indgplon]; fdepth[c]=depth[indgplat,indgplon]
							foni[c]=oni[indgplat,indgplon]; fhsmz[c]=hsmz[indgplat,indgplon]
							# cyclone info
							fcmap[c]=acmap[indgplat,indgplon]
							# time
							ftime[c]=np.double(wtime[indtauxw[t]])
							fmonth[c]=np.int(time.gmtime(wtime[indtauxw[t]])[1])

							c=c+1

						del indgplat, indgplon

					del inds, acmap, whs, wwnd

				print(repr(t))

			f.close(); del f

fcy.close(); del fcy
print(' Data Collocation/Matchups Ok.')

# Quality Control
ind=np.where( (fwhs>0.0) & (fwhs<20.0) & (fwwnd>0.0) & (fwwnd<60.0) & (fshs>0.0) & (fshs<20.0) & (fswnd>0.0) & (fswnd<60.0) )
if size(ind)>0:
	print(' Total amount of matchups model/satellite: '+repr(size(ind)))
	fwhs=np.array(fwhs[ind[0]]); fwwnd=np.array(fwwnd[ind[0]])
	fshs=np.array(fshs[ind[0]]); fswnd=np.array(fswnd[ind[0]]); fsid=np.array(fsid[ind[0]]).astype('int')
	flat=np.array(flat[ind[0]]); flon=np.array(flon[ind[0]])
	ftime=np.array(ftime[ind[0]]).astype('double'); fmonth=np.array(fmonth[ind[0]]).astype('int')
	fdistcoast=np.array(fdistcoast[ind[0]]); fdepth=np.array(fdepth[ind[0]])
	foni=np.array(foni[ind[0]]).astype('int'); fhsmz=np.array(fhsmz[ind[0]]).astype('int'); fcmap=np.array(fcmap[ind[0]]).astype('int')

	initime=repr(time.gmtime(ftime.min())[0])+str(time.gmtime(ftime.min())[1]).zfill(2)+str(time.gmtime(ftime.min())[2]).zfill(2)+str(time.gmtime(ftime.min())[3]).zfill(2)
	fintime=repr(time.gmtime(ftime.max())[0])+str(time.gmtime(ftime.max())[1]).zfill(2)+str(time.gmtime(ftime.max())[2]).zfill(2)+str(time.gmtime(ftime.max())[3]).zfill(2)
	# Save netcdf output file
	ncfile = nc.Dataset('WW3.Altimeter_'+initime+'to'+fintime+'.nc', "w", format=fnetcdf)
	ncfile.history="Matchups of WAVEWATCHIII and AODN Altimeter data. Total of "+repr(size(ind))+" observations or pairs model/observation."
	# create  dimensions. 2 Dimensions
	ncfile.createDimension('time',ftime.shape[0])
	ncfile.createDimension('satellite', sdname.shape[0] )
	ncfile.createDimension('GlobalOceansSeas', ocnames.shape[0] )
	ncfile.createDimension('HighSeasMarineZones', hsmznames.shape[0] )
	ncfile.createDimension('cycloneinfo', cinfo.shape[0] )
	# create variables.
	vt = ncfile.createVariable('time',np.dtype('float64').char,('time'))
	vmonth = ncfile.createVariable('month',np.dtype('int16').char,('time'))	
	vlat = ncfile.createVariable('latitude',np.dtype('float32').char,('time'))
	vlon = ncfile.createVariable('longitude',np.dtype('float32').char,('time'))
	vdistcoast = ncfile.createVariable('distcoast',np.dtype('float32').char,('time'))
	vdepth = ncfile.createVariable('depth',np.dtype('float32').char,('time'))
	voni = ncfile.createVariable('GlobalOceansSeas',np.dtype('int16').char,('time'))
	vocnames = ncfile.createVariable('names_GlobalOceansSeas',dtype('a25'),('GlobalOceansSeas'))
	vhsmz = ncfile.createVariable('HighSeasMarineZones',np.dtype('int16').char,('time'))
	vhsmznames = ncfile.createVariable('names_HighSeasMarineZones',dtype('a25'),('HighSeasMarineZones'))
	vcmap = ncfile.createVariable('cyclone',np.dtype('int16').char,('time'))
	vcinfo = ncfile.createVariable('cycloneinfo',dtype('a25'),('cycloneinfo'))
	vsid = ncfile.createVariable('satelliteID',np.dtype('int16').char,('time'))
	vsdname = ncfile.createVariable('names_satellite',dtype('a25'),('HighSeasMarineZones'))
	# results
	vwhs = ncfile.createVariable('hs_model',np.dtype('float32').char,('time'))
	vwwnd = ncfile.createVariable('wnd_model',np.dtype('float32').char,('time'))
	vshs = ncfile.createVariable('hs_obsv',np.dtype('float32').char,('time'))
	vswnd = ncfile.createVariable('wnd_obsv',np.dtype('float32').char,('time'))
	# Assign units
	vlat.units = 'degrees_north' ; vlon.units = 'degrees_east'
	vt.units = 'seconds since 1970-01-01T00:00:00+00:00'
	vwhs.units='m'; vshs.units='m'
	vwwnd.units='m/s'; vswnd.units='m/s'
	# Allocate Data
	vt[:]=ftime[:]; vmonth[:]=fmonth[:]
	vlat[:] = flat[:]; vlon[:] = flon[:]
	vdistcoast[:] = fdistcoast[:]; vdepth[:] = fdepth[:]
	voni[:] = foni[:]; vocnames[:] = ocnames[:]
	vhsmz[:] = fhsmz[:]; vhsmznames[:] = hsmznames[:]
	vcmap[:] = fcmap[:]; vcinfo[:] = cinfo[:]
	vwhs[:] = fwhs[:]; vshs[:] = fshs[:]
	vwwnd[:] = fwwnd[:]; vswnd[:] = fswnd[:]
	#
	ncfile.close()
	print(' ')
	print('Done. Netcdf ok. New file saved: WW3.Altimeter_'+initime+'to'+fintime+'.nc')


