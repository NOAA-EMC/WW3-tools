# This script creates a map with cyclone information, using the resolution of gridInfo (generated by preprGridMask.py) and IBTracks.
# The result is a simple netcdf with integers, as explained at ncfile.info
# For long hindcast/reforecasts it is better to run this code by year. It reads an argument with the year of interest, np.int(sys.argv[1])
# the nohup line below shows an example of how to run multiple years at the same time.

import pylab
from pylab import *
from matplotlib.mlab import *
import geopy.distance
import netCDF4 as nc
import numpy as np
import sys
import time
from calendar import timegm
import matplotlib.pyplot as plt
import pandas as pd
fnetcdf="NETCDF4"

# nohup python3 procyclmap.py 2019 >> nohup_cyclmap_2019.txt 2>&1 &

year=np.int(sys.argv[1]) # input argument
datelim=np.str(year)+'123123'
# 3-hourly data, if you want to change the time resolution, please edit the next line.
ftime = np.array(np.arange(float(timegm( time.strptime(np.str(year)+'010100', '%Y%m%d%H') )),float(timegm( time.strptime(datelim, '%Y%m%d%H') ))+1,3.*3600.)).astype('double')
# Cyclone radius (km) for tropical cyclones, followed by its transition to extratropical 
# https://journals.ametsoc.org/view/journals/clim/29/8/jcli-d-15-0731.1.xml
# https://www.nhc.noaa.gov/pdf/carrasco-etal-wf2014.pdf
tcr=500.; etr=1000.

# READ mask
f=nc.Dataset('gridInfo.nc')
latm=f.variables['latitude'][:]; lonm=f.variables['longitude'][:]
maskm=f.variables['mask'][:,:]; mdist=f.variables['distcoast'][:,:]
f.close(); del f
# -------------

# --- Read Tracks -----
# READ IBTRACKS V4 https://www.ncei.noaa.gov/data/international-best-track-archive-for-climate-stewardship-ibtracs/v04r00/access/csv/
# https://www.ncdc.noaa.gov/ibtracs/index.php?name=bib
# http://www.euro4m.eu/Presentations_ACRE/Diamond_acre_11_IBTrACS.pdf
# https://www.fgdl.org/metadata/fgdl_html/tropc_dec13.htm
# Storm nature: TS - storm is tropical SS - Subtropical ET - Extratropical DS - Disturbance MX - Mix of conflicting reports NR - Not Reported MM - Missing
# pick TS,SS,DS,ET,MX/NR . Exclude MX,NR

ity=[];itm=[];itd=[];ith=[];ilat=[];ilon=[];inat=[]
# North Atlantic
dfibtr = pd.read_csv('ibtracs.since1980.list.v04r00.csv', header=[0,1])
inat=np.append(inat,dfibtr.values[:,7]); ilat=np.append(ilat,dfibtr.values[:,8]); ilon=np.append(ilon,dfibtr.values[:,9])
ity=np.append(ity,np.array(pd.Series(dfibtr['ISO_TIME'].values.flatten()).str.slice(0,4)).astype('int'))
itm=np.append(itm,np.array(pd.Series(dfibtr['ISO_TIME'].values.flatten()).str.slice(5,7)).astype('int'))
itd=np.append(itd,np.array(pd.Series(dfibtr['ISO_TIME'].values.flatten()).str.slice(8,10)).astype('int'))
ith=np.append(ith,np.array(pd.Series(dfibtr['ISO_TIME'].values.flatten()).str.slice(11,13)).astype('int'))
print('Ibtracks ok'); del dfibtr
ind=np.where(ity>=2000)
ity=np.copy(ity[ind[0]]);itm=np.copy(itm[ind[0]]); itd=np.copy(itd[ind[0]]); ith=np.copy(ith[ind[0]])
ilat=np.copy(ilat[ind[0]]);ilon=np.copy(ilon[ind[0]]);inat=np.copy(inat[ind[0]])
del ind
ilon[ilon<0]=ilon[ilon<0]+360.

# -----------
# Organize time
ind=np.where(ity==np.float(year))[0]; inat=np.copy(np.array(inat[ind]))
ilat=np.copy(np.array(ilat[ind]).astype('int')); ilon=np.copy(np.array(ilon[ind]).astype('int'))
ity=np.copy(np.array(ity[ind]).astype('int')); itm=np.copy(np.array(itm[ind]).astype('int'))
itd=np.copy(np.array(itd[ind]).astype('int')); ith=np.copy(np.array(ith[ind]).astype('int'))
del ind; it=[]
for i in range(0,size(ity)):
	it = np.append(it,np.array(timegm( time.strptime(repr(ity[i])+str(itm[i]).zfill(2)+str(itd[i]).zfill(2)+str(ith[i]).zfill(2), '%Y%m%d%H') )).astype('double'))

# -----------

# resolution
gres=np.diff(latm).mean()
# displacement for the cyclone area
dglat = np.int(np.ceil(((etr/100.)+1.0)/gres))
# Final array of mask
cmask=np.zeros((ftime.shape[0],maskm.shape[0],maskm.shape[1]),'i')
# loop through all times
for t in range(0,ftime.shape[0]):
	cmask[t,:,:]=cmask[t,:,:]*maskm
	# search for cyclones on that time, using +- 1 hour
	# Tropical cyclones
	indt = np.where( (it>=(ftime[t]-5401)) & (it<=(ftime[t]+5401)) )
	if np.size(indt)>0.:
		# if cyclones found (one or more), loop through cyclones
		indt=np.array(indt[0]).astype('int')
		for i in range(0,indt.shape[0]):
			# center of the cyclone
			indilat=np.where( np.abs(latm-ilat[indt[i]])==np.min(np.abs(latm-ilat[indt[i]])) )[0][0]
			indilon=np.where( np.abs(lonm-ilon[indt[i]])==np.min(np.abs(lonm-ilon[indt[i]])) )[0][0]

			# Index of grid points whithin the cyclone
			rlat=np.array(np.where( (latm>=latm[indilat]-gres*dglat) & (latm<=latm[indilat]+gres*dglat) )[0]).astype('int')
			dglon = np.int(np.ceil((etr/(90./(1/np.cos(np.abs(latm)[np.int(np.round(np.mean(rlat)))]*(pi/180)))))/gres))
			rlon=np.array(np.where( (lonm>=lonm[indilon]-gres*dglon) & (lonm<=lonm[indilon]+gres*dglon) )[0]).astype('int')
			if np.abs(ilat[indt[i]])<40.:
				etrl= tcr + np.max([0,np.abs(ilat[indt[i]])-20.])*(etr-tcr)/20.
			else:
				etrl=etr

			for j in range(0,rlat.shape[0]):
				for k in range(0,rlon.shape[0]):
					cdist=np.float(geopy.distance.great_circle((latm[rlat[j]],lonm[rlon[k]]), (latm[indilat],lonm[indilon]) ).kilometers)
					if (cdist<=etrl) and (maskm[rlat[j],rlon[k]]>=0.):
						if inat[indt[i]]=='TS':
							cmask[t,rlat[j],rlon[k]]=np.int(5)
						elif inat[indt[i]]=='SS':
							cmask[t,rlat[j],rlon[k]]=np.int(4)
						elif inat[indt[i]]=='ET':
							cmask[t,rlat[j],rlon[k]]=np.int(3)
						elif inat[indt[i]]=='DS':
							cmask[t,rlat[j],rlon[k]]=np.int(2)
						else:
							cmask[t,rlat[j],rlon[k]]=np.int(1)

					del cdist

			del rlat,rlon,indilat,indilon

		del indt

	print('  t : '+repr(t)+'   of '+repr(ftime.shape[0]))

# Save netcdf
# cmask, ftime, latm, lonm
cmask[cmask<0.]=-1
ncfile = nc.Dataset('CycloneMap_'+repr(year)+'.nc', "w", format=fnetcdf) 
ncfile.history='Cyclone Map using IBtracks cyclone tracks, with same grid resolution as GEFSv12 winds.'
ncfile.info='IDs: 0(no cyclone), 1(Missing,conflicting,or not reported), 2(disturbance), 3(extratropical), 4(subtropical storm/cyclone), 5(tropical storm/cyclone).'
# create  dimensions.
ncfile.createDimension('time', ftime.shape[0])
ncfile.createDimension('lat', latm.shape[0])
ncfile.createDimension('lon', lonm.shape[0])
# time, forecast time, lat, and lon
vt = ncfile.createVariable('time',np.dtype('float64'),('time'))
vlat = ncfile.createVariable('lat',dtype('float32'),('lat',))
vlon = ncfile.createVariable('lon',np.dtype('float32'),('lon'))
# Model results
vcmap = ncfile.createVariable('cmap',np.dtype('int32'),('time','lat','lon'))
# Units
vlat.units = 'degrees_north' ; vlon.units = 'degrees_east'
# Allocate Data
vt[:] = ftime; vlat[:] = latm; vlon[:] = lonm
vcmap[:,:,:] = cmask
ncfile.close()
print('netcdf ok ')

