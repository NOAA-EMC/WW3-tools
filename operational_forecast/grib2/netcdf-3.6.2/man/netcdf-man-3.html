<!-- Creator     : groff version 1.18.1.1 -->
<!-- CreationDate: Thu Mar  1 15:48:12 2007 -->
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta name="Content-Style" content="text/css">
<title>NETCDF</title>
</head>
<body>

<h1 align=center>NETCDF</h1>
<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#LIBRARY VERSION">LIBRARY VERSION</a><br>
<a href="#RETURN VALUES">RETURN VALUES</a><br>
<a href="#COMMON ARGUMENT DESCRIPTIONS">COMMON ARGUMENT DESCRIPTIONS</a><br>
<a href="#VARIABLE PREFILLING">VARIABLE PREFILLING</a><br>
<a href="#MPP FUNCTION DESCRIPTIONS">MPP FUNCTION DESCRIPTIONS</a><br>
<a href="#ENVIRONMENT VARIABLES">ENVIRONMENT VARIABLES</a><br>
<a href="#MAILING-LISTS">MAILING-LISTS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>
<a name="NAME"></a>
<h2>NAME</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>netcdf &minus; Unidata Network Common Data Form (netCDF)
library, version 3 interface</p>
</td>
</table>
<a name="SYNOPSIS"></a>
<h2>SYNOPSIS</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>#include &quot;netcdf.h&quot;</b></p>
<!-- INDENTATION -->
<p><b>cc ... -lnetcdf</b></p>
</td>
</table>
<a name="LIBRARY VERSION"></a>
<h2>LIBRARY VERSION</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>This document describes version 3 of Unidata netCDF
data-access interface for the C programming language.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const char* nc_inq_libvers()</b></p>
<!-- INDENTATION -->
<p>Returns a string identifying the version of the netCDF
library, and when it was built, like: &quot;3.1a of Aug 22
1996 12:57:47 $&quot;.</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>The RCS <b>ident(1)</b> command will find a string like
&quot;$Id: @(#) netcdf library version 3.1a of Sep 6 1996
15:56:26 $&quot; in the library. The SCCS <b>what(1)</b>
command will find a string like &quot;netcdf library version
3.1a of Aug 23 1996 16:07:40 $&quot;.</p>
</td>
</table>
<a name="RETURN VALUES"></a>
<h2>RETURN VALUES</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>All netCDF functions (except <b>nc_inq_libvers()</b> and
<b>nc_strerror()</b>) return an integer status. This
behavior replaces the <b>ncerr()</b> function used in
previous versions of the library. If this returned status
value is not equal to <b>NC_NOERR</b> (zero), it indicates
that an error occurred. The possible status values are
defined in system include file &lt;errno.h&gt; and in
&quot;netcdf.h&quot;.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>const char* nc_strerror(int</b>
<i>status</i><b>)</b></p>
<!-- INDENTATION -->
<p>Returns a string textual translation of the <i>status</i>
value, like &quot;Attribute or variable name contains
illegal characters&quot; or &quot;No such file or
directory&quot;.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_create(const char</b> <i>path</i><b>[], int</b>
<i>cmode</i><b>, int*</b> <i>ncid</i><b>)</b></p>
<!-- INDENTATION -->
<p>(Corresponds to <b>nccreate()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Creates a new netCDF dataset at <i>path</i>, returning a
netCDF ID in <i>ncid</i>. The argument <i>cmode</i> may
include the bitwise-or of the following flags:
<b>NC_NOCLOBBER</b> to protect existing datasets (default
silently blows them away), <b>NC_SHARE</b> for synchronous
dataset updates (default is to buffer accesses), and
<b>NC_LOCK</b> (not yet implemented). When a netCDF dataset
is created, is is opened <b>NC_WRITE</b>. The new netCDF
dataset is in define mode. <b>NC_64BIT_OFFSET</b>. to create
a file in the 64-bit offset (as opposed to classic , the
default). 64-bit offset allows the creation of very large
files with far fewer restrictions than netCDF classic , but
can only be read by the netCDF library version 3.6 or
greater. Users are cautioned that files that use the 64-bit
offset will not be recognized by netCDF applications linked
to an earlier version of the netCDF library than 3.6.
Applications linked to version 3.6 or later will be able to
transparently access either the classic or 64-bit offset
.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc__create(const char</b> <i>path</i><b>[],
int</b> <i>cmode</i><b>, size_t</b> <i>initialsize</i><b>,
size_t*</b> <i>chunksize</i><b>, int*</b>
<i>ncid</i><b>)</b></p>
<!-- INDENTATION -->
<p>Like <b>nc_create()</b> but has additional performance
tuning parameters.</p>
<!-- INDENTATION -->
<p>The argument <i>initialsize</i> sets the initial size of
the file at creation time.</p>
<!-- INDENTATION -->
<p>See <b>nc__open()</b> below for an explanation of the
<i>chunksize</i> parameter.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_open(const char</b> <i>path</i><b>[], int</b>
<i>mode</i><b>, int*</b> <i>ncid</i><b>)</b></p>
<!-- INDENTATION -->
<p>(Corresponds to <b>ncopen()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Opens a existing netCDF dataset at <i>path</i> returning
a netCDF ID in <i>ncid</i>. The type of access is described
by the <i>mode</i> parameter, which may include the
bitwise-or of the following flags: <b>NC_WRITE</b> for
read-write access (default read-only), <b>NC_SHARE</b> for
synchronous dataset updates (default is to buffer accesses),
and <b>NC_LOCK</b> (not yet implemented).</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc__open(const char</b> <i>path</i><b>[], int</b>
<i>mode</i><b>, size_t*</b> <i>chunksize</i><b>, int*</b>
<i>ncid</i><b>)</b></p>
<!-- INDENTATION -->
<p>Like <b>nc_open()</b> but has an additional performance
tuning parameter.</p>
<!-- INDENTATION -->
<p>The argument referenced by <i>chunksize</i> controls a
space versus time tradeoff, memory allocated in the netcdf
library versus number of system calls. Because of internal
requirements, the value may not be set to exactly the value
requested. The actual value chosen is returned by reference.
Using the value <b>NC_SIZEHINT_DEFAULT</b> causes the
library to choose a default. How the system choses the
default depends on the system. On many systems, the
&quot;preferred I/O block size&quot; is available from the
<b>stat()</b> system call, <b>struct stat</b> member
<b>st_blksize</b>. If this is available it is used. Lacking
that, twice the system pagesize is used. Lacking a call to
discover the system pagesize, we just set default chunksize
to 8192.</p>
<!-- INDENTATION -->
<p>The chunksize is a property of a given open netcdf
descriptor <i>ncid</i>, it is not a persistent property of
the netcdf dataset.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_redef(int</b> <i>ncid</i><b>)</b></p>
<!-- INDENTATION -->
<p>(Corresponds to <b>ncredef()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Puts an open netCDF dataset into define mode, so
dimensions, variables, and attributes can be added or
renamed and attributes can be deleted.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_enddef(int</b> <i>ncid</i><b>)</b></p>
<!-- INDENTATION -->
<p>(Corresponds to <b>ncendef()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Takes an open netCDF dataset out of define mode. The
changes made to the netCDF dataset while it was in define
mode are checked and committed to disk if no problems
occurred. Some data values may be written as well, see
&quot;VARIABLE PREFILLING&quot; below. After a successful
call, variable data can be read or written to the
dataset.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc__enddef(int</b> <i>ncid</i><b>, size_t</b>
<i>h_minfree</i><b>, size_t</b> <i>v_align</i><b>,
size_t</b> <i>v_minfree</i><b>, size_t</b>
<i>r_align</i><b>)</b></p>
<!-- INDENTATION -->
<p>Like <b>nc_enddef()</b> but has additional performance
tuning parameters.</p>
<!-- INDENTATION -->
<p>Caution: this function exposes internals of the netcdf
version 1 file format. It may not be available on future
netcdf implementations.</p>
<!-- INDENTATION -->
<p>The current netcdf file format has three sections, the
&quot;header&quot; section, the data section for fixed size
variables, and the data section for variables which have an
unlimited dimension (record variables). The header begins at
the beginning of the file. The index (offset) of the
beginning of the other two sections is contained in the
header. Typically, there is no space between the sections.
This causes copying overhead to accrue if one wishes to
change the size of the sections, as may happen when changing
names of things, text attribute values, adding attributes or
adding variables. Also, for buffered i/o, there may be
advantages to aligning sections in certain ways.</p>
<!-- INDENTATION -->
<p>The minfree parameters allow one to control costs of
future calls to <b>nc_redef()</b>, <b>nc_enddef()</b> by
requesting that <i>minfree</i> bytes be available at the end
of the section. The <i>h_minfree</i> parameter sets the pad
at the end of the &quot;header&quot; section. The
<i>v_minfree</i> parameter sets the pad at the end of the
data section for fixed size variables.</p>
<!-- INDENTATION -->
<p>The align parameters allow one to set the alignment of
the beginning of the corresponding sections. The beginning
of the section is rounded up to an index which is a multiple
of the align parameter. The flag value <b>NC_ALIGN_CHUNK</b>
tells the library to use the chunksize (see above) as the
align parameter. The <i>v_align</i> parameter controls the
alignment of the beginning of the data section for fixed
size variables. The <i>r_align</i> parameter controls the
alignment of the beginning of the data section for variables
which have an unlimited dimension (record variables).</p>
<!-- INDENTATION -->
<p>The file format requires mod 4 alignment, so the align
parameters are silently rounded up to multiples of 4. The
usual call, <b>nc_enddef(</b><i>ncid</i><b>)</b> is
equivalent to <b>nc__enddef(</b><i>ncid</i><b>, 0, 4, 0,
4)</b>.</p>
<!-- INDENTATION -->
<p>The file format does not contain a &quot;record
size&quot; value, this is calculated from the sizes of the
record variables. This unfortunate fact prevents us from
providing minfree and alignment control of the
&quot;records&quot; in a netcdf file. If you add a variable
which has an unlimited dimension, the third section will
always be copied with the new variable added.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_sync(int</b> <i>ncid</i><b>)</b></p>
<!-- INDENTATION -->
<p>(Corresponds to <b>ncsync()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Unless the <b>NC_SHARE</b> bit is set in <b>nc_open()</b>
or <b>nc_create()</b>, accesses to the underlying netCDF
dataset are buffered by the library. This function
synchronizes the state of the underlying dataset and the
library. This is done automatically by <b>nc_close()</b> and
<b>nc_enddef()</b>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_abort(int</b> <i>ncid</i><b>)</b></p>
<!-- INDENTATION -->
<p>(Corresponds to <b>ncabort()</b> in version 2)</p>
<!-- INDENTATION -->
<p>You don&rsquo;t need to call this function. This function
is called automatically by <b>nc_close()</b> if the netCDF
was in define mode and something goes wrong with the commit.
If the netCDF dataset isn&rsquo;t in define mode, then this
function is equivalent to <b>nc_close()</b>. If it is called
after <b>nc_redef()</b>, but before <b>nc_enddef()</b>, the
new definitions are not committed and the dataset is closed.
If it is called after <b>nc_create()</b> but before
<b>nc_enddef()</b>, the dataset disappears.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_close(int</b> <i>ncid</i><b>)</b></p>
<!-- INDENTATION -->
<p>(Corresponds to <b>ncclose()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Closes an open netCDF dataset. If the dataset is in
define mode, <b>nc_enddef()</b> will be called before
closing. After a dataset is closed, its ID may be reassigned
to another dataset.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_inq(int</b> <i>ncid</i><b>, int*</b>
<i>ndims</i><b>, int*</b> <i>nvars</i><b>, int*</b>
<i>natts</i><b>, int*</b> <i>unlimdimid</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_inq_ndims(int</b> <i>ncid</i><b>, int*</b>
<i>ndims</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_inq_nvars(int</b> <i>ncid</i><b>, int*</b>
<i>nvars</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_inq_natts(int</b> <i>ncid</i><b>, int*</b>
<i>natts</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_inq_unlimdim(int</b> <i>ncid</i><b>, int*</b>
<i>unlimdimid</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_inq_format(int</b> <i>ncid</i><b>, int*</b>
<i>formatn</i><b>)</b></p>
<!-- INDENTATION -->
<p>(Replace <b>ncinquire()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Use these functions to find out what is in a netCDF
dataset. Upon successful return, <i>ndims</i> will contain
the number of dimensions defined for this netCDF dataset,
<i>nvars</i> will contain the number of variables,
<i>natts</i> will contain the number of attributes, and
<i>unlimdimid</i> will contain the dimension ID of the
unlimited dimension if one exists, or -1 otherwise.
<i>formatn</i> will contain the version number of the
dataset &lt;&gt;, one of <b>NC_FORMAT_CLASSIC</b>,
<b>NC_FORMAT_64BIT</b>, <b>NC_FORMAT_NETCDF4</b>, or
<b>NC_FORMAT_NETCDF4_CLASSIC</b>. If any of the return
parameters is a <b>NULL</b> pointer, then the corresponding
information will not be returned; hence, no space need be
allocated for it.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_def_dim(int</b> <i>ncid</i><b>, const char</b>
<i>name</i><b>[], size_t</b> <i>len</i><b>, int*</b>
<i>dimid</i><b>)</b></p>
<!-- INDENTATION -->
<p>(Corresponds to <b>ncdimdef()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Adds a new dimension to an open netCDF dataset, which
must be in define mode. <i>name</i> is the dimension name.
If <i>dimid</i> is not a <b>NULL</b> pointer then upon
successful completion <i>dimid</i> will contain the
dimension ID of the newly created dimension.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_inq_dimid(int</b> <i>ncid</i><b>, const
char</b> <i>name</i><b>[], int*</b> <i>dimid</i><b>)</b></p>
<!-- INDENTATION -->
<p>(Corresponds to <b>ncdimid()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Given a dimension name, returns the ID of a netCDF
dimension in <i>dimid</i>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_inq_dim(int</b> <i>ncid</i><b>, int</b>
<i>dimid</i><b>, char</b> <i>name</i><b>[], size_t*</b>
<i>len</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_inq_dimname(int</b> <i>ncid</i><b>, int</b>
<i>dimid</i><b>, char</b> <i>name</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_inq_dimlen(int</b> <i>ncid</i><b>, int</b>
<i>dimid</i><b>, size_t*</b> <i>len</i><b>)</b></p>
<!-- INDENTATION -->
<p>(Replace <b>ncdiminq()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Use these functions to find out about a dimension. If
either the <i>name</i> argument or <i>len</i> argument is a
<b>NULL</b> pointer, then the associated information will
not be returned. Otherwise, <i>name</i> should be big enough
(<b>NC_MAX_NAME</b>) to hold the dimension name as the name
will be copied into your storage. The length return
parameter, <i>len</i> will contain the size of the
dimension. For the unlimited dimension, the returned length
is the current maximum value used for writing into any of
the variables which use the dimension.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_rename_dim(int</b> <i>ncid</i><b>, int</b>
<i>dimid</i><b>, const char</b> <i>name</i><b>[])</b></p>
<!-- INDENTATION -->
<p>(Corresponds to <b>ncdimrename()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Renames an existing dimension in an open netCDF dataset.
If the new name is longer than the old name, the netCDF
dataset must be in define mode. You cannot rename a
dimension to have the same name as another dimension.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_def_var(int</b> <i>ncid</i><b>, const char</b>
<i>name</i><b>[], nc_type</b> <i>xtype</i><b>, int</b>
<i>ndims</i><b>, const int</b> <i>dimids</i><b>[], int*</b>
<i>varid</i><b>)</b></p>
<!-- INDENTATION -->
<p>(Corresponds to <b>ncvardef()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Adds a new variable to a netCDF dataset. The netCDF must
be in define mode. If not <b>NULL</b>, then <i>varid</i>
will be set to the netCDF variable ID.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_inq_varid(int</b> <i>ncid</i><b>, const
char</b> <i>name</i><b>[], int*</b> <i>varid</i><b>)</b></p>
<!-- INDENTATION -->
<p>(Corresponds to <b>ncvarid()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Returns the ID of a netCDF variable in <i>varid</i> given
its name.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_inq_var(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, char</b> <i>name</i><b>[], nc_type*</b>
<i>xtype</i><b>, int*</b> <i>ndims</i><b>, int</b>
<i>dimids</i><b>[], int*</b> <i>natts</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_inq_varname(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, char</b> <i>name</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_inq_vartype(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, nc_type*</b> <i>xtype</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_inq_varndims(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, int*</b> <i>ndims</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_inq_vardimid(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, int</b> <i>dimids</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_inq_varnatts(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, int*</b> <i>natts</i><b>)</b></p>
<!-- INDENTATION -->
<p>(Replace <b>ncvarinq()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Returns information about a netCDF variable, given its
ID. If any of the return parameters (<i>name</i>,
<i>xtype</i>, <i>ndims</i>, <i>dimids</i>, or <i>natts</i>)
is a <b>NULL</b> pointer, then the corresponding information
will not be returned; hence, no space need be allocated for
it.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_rename_var(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const char</b> <i>name</i><b>[])</b></p>
<!-- INDENTATION -->
<p>(Corresponds to <b>ncvarrename()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Changes the name of a netCDF variable. If the new name is
longer than the old name, the netCDF must be in define mode.
You cannot rename a variable to have the name of any
existing variable.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_var_text(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const char</b> <i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_var_uchar(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const unsigned char</b>
<i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_var_schar(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const signed char</b>
<i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_var_short(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const short</b> <i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_var_int(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const int</b> <i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_var_long(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const long</b> <i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_var_float(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const float</b> <i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_var_double(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const double</b> <i>out</i><b>[])</b></p>
<!-- INDENTATION -->
<p>(Replace <b>ncvarput()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Writes an entire netCDF variable (i.e. all the values).
The netCDF dataset must be open and in data mode. The type
of the data is specified in the function name, and it is
converted to the external type of the specified variable, if
possible, otherwise an <b>NC_ERANGE</b> error is returned.
Note that rounding is not performed during the conversion.
Floating point numbers are truncated when converted to
integers.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_var_text(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, char</b> <i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_var_uchar(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, unsigned char</b> <i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_var_schar(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, signed char</b> <i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_var_short(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, short</b> <i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_var_int(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, int</b> <i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_var_long(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, long</b> <i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_var_float(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, float</b> <i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_var_double(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, double</b> <i>in</i><b>[])</b></p>
<!-- INDENTATION -->
<p>(Replace <b>ncvarget()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Reads an entire netCDF variable (i.e. all the values).
The netCDF dataset must be open and in data mode. The data
is converted from the external type of the specified
variable, if necessary, to the type specified in the
function name. If conversion is not possible, an
<b>NC_ERANGE</b> error is returned.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_var1_text(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>index</i><b>[],
char</b> <i>*out</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_var1_uchar(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>index</i><b>[],
unsigned char</b> <i>*out</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_var1_schar(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>index</i><b>[], signed
char</b> <i>*out</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_var1_short(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>index</i><b>[],
short</b> <i>*out</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_var1_int(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>index</i><b>[], int</b>
<i>*out</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_var1_long(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>index</i><b>[],
long</b> <i>*out</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_var1_float(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>index</i><b>[],
float</b> <i>*out</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_var1_double(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>index</i><b>[],
double</b> <i>*out</i><b>)</b></p>
<!-- INDENTATION -->
<p>(Replace <b>ncvarput1()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Puts a single data value into a variable at the position
<i>index</i> of an open netCDF dataset that is in data mode.
The type of the data is specified in the function name, and
it is converted to the external type of the specified
variable, if possible, otherwise an <b>NC_ERANGE</b> error
is returned.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_var1_text(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>index</i><b>[],
char*</b> <i>in</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_var1_uchar(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>index</i><b>[],
unsigned char*</b> <i>in</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_var1_schar(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>index</i><b>[], signed
char*</b> <i>in</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_var1_short(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>index</i><b>[],
short*</b> <i>in</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_var1_int(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>index</i><b>[],
int*</b> <i>in</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_var1_long(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>index</i><b>[],
long*</b> <i>in</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_var1_float(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>index</i><b>[],
float*</b> <i>in</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_var1_double(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>index</i><b>[],
double*</b> <i>in</i><b>)</b></p>
<!-- INDENTATION -->
<p>(Replace <b>ncvarget1()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Gets a single data value from a variable at the position
<i>index</i> of an open netCDF dataset that is in data mode.
The data is converted from the external type of the
specified variable, if necessary, to the type specified in
the function name. If conversion is not possible, an
<b>NC_ERANGE</b> error is returned.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_vara_text(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const char</b>
<i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_vara_uchar(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const unsigned char</b>
<i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_vara_schar(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const signed char</b>
<i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_vara_short(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const short</b>
<i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_vara_int(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const int</b>
<i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_vara_long(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const long</b>
<i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_vara_float(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const float</b>
<i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_vara_double(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const double</b>
<i>out</i><b>[])</b></p>
<!-- INDENTATION -->
<p>(Replace <b>ncvarput()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Writes an array section of values into a netCDF variable
of an open netCDF dataset, which must be in data mode. The
array section is specified by the <i>start</i> and
<i>count</i> vectors, which give the starting index and
count of values along each dimension of the specified
variable. The type of the data is specified in the function
name and is converted to the external type of the specified
variable, if possible, otherwise an <b>NC_ERANGE</b> error
is returned.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_vara_text(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], char</b>
<i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_vara_uchar(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], unsigned char</b>
<i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_vara_schar(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], signed char</b>
<i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_vara_short(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], short</b>
<i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_vara_int(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], int</b>
<i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_vara_long(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], long</b>
<i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_vara_float(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], float</b>
<i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_vara_double(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], double</b>
<i>in</i><b>[])</b></p>
<!-- INDENTATION -->
<p>(Corresponds to <b>ncvarget()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Reads an array section of values from a netCDF variable
of an open netCDF dataset, which must be in data mode. The
array section is specified by the <i>start</i> and
<i>count</i> vectors, which give the starting index and
count of values along each dimension of the specified
variable. The data is converted from the external type of
the specified variable, if necessary, to the type specified
in the function name. If conversion is not possible, an
<b>NC_ERANGE</b> error is returned.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_vars_text(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[], const char</b> <i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_vars_uchar(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[], const unsigned char</b>
<i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_vars_schar(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[], const signed char</b>
<i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_vars_short(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[], const short</b> <i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_vars_int(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[], const int</b> <i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_vars_long(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[], const long</b> <i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_vars_float(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[], const float</b> <i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_vars_double(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[], const double</b>
<i>out</i><b>[])</b></p>
<!-- INDENTATION -->
<p>(Corresponds to <b>ncvarputg()</b> in version 2)</p>
<!-- INDENTATION -->
<p>These functions are used for <i>strided output</i>, which
is like the array section output described above, except
that the sampling stride (the interval between accessed
values) is specified for each dimension. For an explanation
of the sampling stride vector, see COMMON ARGUMENTS
DESCRIPTIONS below.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_vars_text(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[], char</b> <i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_vars_uchar(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[], unsigned char</b>
<i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_vars_schar(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[], signed char</b> <i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_vars_short(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[], short</b> <i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_vars_int(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[], int</b> <i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_vars_long(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[], long</b> <i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_vars_float(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[], float</b> <i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_vars_double(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[], double</b> <i>in</i><b>[])</b></p>
<!-- INDENTATION -->
<p>(Corresponds to <b>ncvargetg()</b> in version 2)</p>
<!-- INDENTATION -->
<p>These functions are used for <i>strided input</i>, which
is like the array section input described above, except that
the sampling stride (the interval between accessed values)
is specified for each dimension. For an explanation of the
sampling stride vector, see COMMON ARGUMENTS DESCRIPTIONS
below.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_varm_text(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[],</b> <i>imap</i><b>, const char</b>
<i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_varm_uchar(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[],</b> <i>imap</i><b>, const unsigned
char</b> <i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_varm_schar(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[],</b> <i>imap</i><b>, const signed
char</b> <i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_varm_short(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[],</b> <i>imap</i><b>, const short</b>
<i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_varm_int(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[],</b> <i>imap</i><b>, const int</b>
<i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_varm_long(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[],</b> <i>imap</i><b>, const long</b>
<i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_varm_float(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[],</b> <i>imap</i><b>, const float</b>
<i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_varm_double(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[],</b> <i>imap</i><b>, const double</b>
<i>out</i><b>[])</b></p>
<!-- INDENTATION -->
<p>(Corresponds to <b>ncvarputg()</b> in version 2)</p>
<!-- INDENTATION -->
<p>These functions are used for <i>mapped output</i>, which
is like strided output described above, except that an
additional index mapping vector is provided to specify the
in-memory arrangement of the data values. For an explanation
of the index mapping vector, see COMMON ARGUMENTS
DESCRIPTIONS below.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_varm_text(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[],</b> <i>imap</i><b>, char</b>
<i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_varm_uchar(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[],</b> <i>imap</i><b>, unsigned char</b>
<i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_varm_schar(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[],</b> <i>imap</i><b>, signed char</b>
<i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_varm_short(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[],</b> <i>imap</i><b>, short</b>
<i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_varm_int(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[],</b> <i>imap</i><b>, int</b>
<i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_varm_long(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[],</b> <i>imap</i><b>, long</b>
<i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_varm_float(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[],</b> <i>imap</i><b>, float</b>
<i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_varm_double(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const size_t</b> <i>start</i><b>[], const
size_t</b> <i>count</i><b>[], const size_t</b>
<i>stride</i><b>[],</b> <i>imap</i><b>, double</b>
<i>in</i><b>[])</b></p>
<!-- INDENTATION -->
<p>(Corresponds to <b>ncvargetg()</b> in version 2)</p>
<!-- INDENTATION -->
<p>These functions are used for <i>mapped input</i>, which
is like strided input described above, except that an
additional index mapping vector is provided to specify the
in-memory arrangement of the data values. For an explanation
of the index mapping vector, see COMMON ARGUMENTS
DESCRIPTIONS below.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_att_text(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const char</b> <i>name</i><b>[],
nc_type</b> <i>xtype</i><b>, size_t</b> <i>len</i><b>, const
char</b> <i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_att_uchar(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const char</b> <i>name</i><b>[],
nc_type</b> <i>xtype</i><b>, size_t</b> <i>len</i><b>, const
unsigned char</b> <i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_att_schar(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const char</b> <i>name</i><b>[],
nc_type</b> <i>xtype</i><b>, size_t</b> <i>len</i><b>, const
signed char</b> <i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_att_short(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const char</b> <i>name</i><b>[],
nc_type</b> <i>xtype</i><b>, size_t</b> <i>len</i><b>, const
short</b> <i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_att_int(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const char</b> <i>name</i><b>[],
nc_type</b> <i>xtype</i><b>, size_t</b> <i>len</i><b>, const
int</b> <i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_att_long(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const char</b> <i>name</i><b>[],
nc_type</b> <i>xtype</i><b>, size_t</b> <i>len</i><b>, const
long</b> <i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_att_float(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const char</b> <i>name</i><b>[],
nc_type</b> <i>xtype</i><b>, size_t</b> <i>len</i><b>, const
float</b> <i>out</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_put_att_double(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const char</b> <i>name</i><b>[],
nc_type</b> <i>xtype</i><b>, size_t</b> <i>len</i><b>, const
double</b> <i>out</i><b>[])</b></p>
<!-- INDENTATION -->
<p>(Replace <b>ncattput()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Unlike variables, attributes do not have separate
functions for defining and writing values. This family of
functions defines a new attribute with a value or changes
the value of an existing attribute. If the attribute is new,
or if the space required to store the attribute value is
greater than before, the netCDF dataset must be in define
mode. The parameter <i>len</i> is the number of values from
<i>out</i> to transfer. It is often one, except that for
<b>nc_put_att_text()</b> it will usually be
<b>strlen(</b><i>out</i><b>)</b>.</p>
<!-- INDENTATION -->
<p>For these functions, the type component of the function
name refers to the in-memory type of the value, whereas the
<i>xtype</i> argument refers to the external type for
storing the value. An <b>NC_ERANGE</b> error results if a
conversion between these types is not possible. In this case
the value is represented with the appropriate fill-value for
the associated external type.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_inq_attname(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, int</b> <i>attnum</i><b>, char</b>
<i>name</i><b>[])</b></p>
<!-- INDENTATION -->
<p>(Corresponds to <b>ncattname()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Gets the name of an attribute, given its variable ID and
attribute number. This function is useful in generic
applications that need to get the names of all the
attributes associated with a variable, since attributes are
accessed by name rather than number in all other attribute
functions. The number of an attribute is more volatile than
the name, since it can change when other attributes of the
same variable are deleted. The attributes for each variable
are numbered from 0 (the first attribute) to
<i>nvatts</i>-1, where <i>nvatts</i> is the number of
attributes for the variable, as returned from a call to
<b>nc_inq_varnatts()</b>. If the <i>name</i> parameter is a
<b>NULL</b> pointer, no name will be returned and no space
need be allocated.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_inq_att(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const char</b> <i>name</i><b>[],
nc_type*</b> <i>xtype</i><b>, size_t*</b>
<i>len</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_inq_attid(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const char</b> <i>name</i><b>[], int*</b>
<i>attnum</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_inq_atttype(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const char</b> <i>name</i><b>[],
nc_type*</b> <i>xtype</i><b>)</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_inq_attlen(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const char</b> <i>name</i><b>[],
size_t*</b> <i>len</i><b>)</b></p>
<!-- INDENTATION -->
<p>(Corresponds to <b>ncattinq()</b> in version 2)</p>
<!-- INDENTATION -->
<p>These functions return information about a netCDF
attribute, given its variable ID and name. The information
returned is the external type in <i>xtype</i> and the number
of elements in the attribute as <i>len</i>. If any of the
return arguments is a <b>NULL</b> pointer, the specified
information will not be returned.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_copy_att(int</b> <i>ncid</i><b>, int</b>
<i>varid_in</i><b>, const char</b> <i>name</i><b>[], int</b>
<i>ncid_out</i><b>, int</b> <i>varid_out</i><b>)</b></p>
<!-- INDENTATION -->
<p>(Corresponds to <b>ncattcopy()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Copies an attribute from one netCDF dataset to another.
It can also be used to copy an attribute from one variable
to another within the same netCDF. <i>ncid_in</i> is the
netCDF ID of an input netCDF dataset from which the
attribute will be copied. <i>varid_in</i> is the ID of the
variable in the input netCDF dataset from which the
attribute will be copied, or <b>NC_GLOBAL</b> for a global
attribute. <i>name</i> is the name of the attribute in the
input netCDF dataset to be copied. <i>ncid_out</i> is the
netCDF ID of the output netCDF dataset to which the
attribute will be copied. It is permissible for the input
and output netCDF ID&rsquo;s to be the same. The output
netCDF dataset should be in define mode if the attribute to
be copied does not already exist for the target variable, or
if it would cause an existing target attribute to grow.
<i>varid_out</i> is the ID of the variable in the output
netCDF dataset to which the attribute will be copied, or
<b>NC_GLOBAL</b> to copy to a global attribute.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_rename_att(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const char</b> <i>name</i><b>[], const
char</b> <i>newname</i><b>[])</b></p>
<!-- INDENTATION -->
<p>(Corresponds to <b>ncattrename()</b></p>
<!-- INDENTATION -->
<p>Changes the name of an attribute. If the new name is
longer than the original name, the netCDF must be in define
mode. You cannot rename an attribute to have the same name
as another attribute of the same variable. <i>name</i> is
the original attribute name. <i>newname</i> is the new name
to be assigned to the specified attribute. If the new name
is longer than the old name, the netCDF dataset must be in
define mode.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_del_att(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const char</b> <i>name</i><b>[])</b></p>
<!-- INDENTATION -->
<p>(Corresponds to <b>ncattdel()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Deletes an attribute from a netCDF dataset. The dataset
must be in define mode.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_att_text(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const char</b> <i>name</i><b>[], char</b>
<i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_att_uchar(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const char</b> <i>name</i><b>[], unsigned
char</b> <i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_att_schar(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const char</b> <i>name</i><b>[], signed
char</b> <i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_att_short(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const char</b> <i>name</i><b>[], short</b>
<i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_att_int(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const char</b> <i>name</i><b>[], int</b>
<i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_att_long(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const char</b> <i>name</i><b>[], long</b>
<i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_att_float(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const char</b> <i>name</i><b>[], float</b>
<i>in</i><b>[])</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_get_att_double(int</b> <i>ncid</i><b>, int</b>
<i>varid</i><b>, const char</b> <i>name</i><b>[], double</b>
<i>in</i><b>[])</b></p>
<!-- INDENTATION -->
<p>(Replace <b>ncattget()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Gets the value(s) of a netCDF attribute, given its
variable ID and name. Converts from the external type to the
type specified in the function name, if possible, otherwise
returns an <b>NC_ERANGE</b> error. All elements of the
vector of attribute values are returned, so you must
allocate enough space to hold them. If you don&rsquo;t know
how much space to reserve, call <b>nc_inq_attlen()</b> first
to find out the length of the attribute.</p>
</td>
</table>
<a name="COMMON ARGUMENT DESCRIPTIONS"></a>
<h2>COMMON ARGUMENT DESCRIPTIONS</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>In this section we define some common arguments which are
used in the &quot;FUNCTION DESCRIPTIONS&quot; section.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>int <i>ncid</i></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>is the netCDF ID returned from a previous, successful
call to <b>nc_open()</b> or <b>nc_create()</b></p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>char <i>name</i>[]</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>is the name of a dimension, variable, or attribute. The
names of dimensions, variables and attributes consist of
arbitrary sequences of alphanumeric characters (as well as
underscore &rsquo;_&rsquo;, period &rsquo;.&rsquo; and
hyphen &rsquo;-&rsquo;), beginning with a letter or
underscore. (However names commencing with underscore are
reserved for system use.) Case is significant in netCDF
names. A zero-length name is not allowed. As an input
argument, it shall be a pointer to a 0-terminated string; as
an output argument, it shall be the address of a buffer in
which to hold such a string. The maximum allowable number of
characters (excluding the terminating 0) is
<b>NC_MAX_NAME</b>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>nc_type <i>xtype</i></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>specifies the external data type of a netCDF variable or
attribute and is one of the following: <b>NC_BYTE</b>,
<b>NC_CHAR</b>, <b>NC_SHORT</b>, <b>NC_INT</b>,
<b>NC_FLOAT</b>, or <b>NC_DOUBLE</b>. These are used to
specify 8-bit integers, characters, 16-bit integers, 32-bit
integers, 32-bit IEEE floating point numbers, and 64-bit
IEEE floating-point numbers, respectively. (<b>NC_INT</b>
corresponds to <b>NC_LONG</b> in version 2, to specify a
32-bit integer).</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>int <i>dimids</i>[]</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>is a vector of dimension ID&rsquo;s and defines the shape
of a netCDF variable. The size of the vector shall be
greater than or equal to the rank (i.e. the number of
dimensions) of the variable (<i>ndims</i>). The vector shall
be ordered by the speed with which a dimension varies:
<i>dimids</i>[<i>ndims</i>-1] shall be the dimension ID of
the most rapidly varying dimension and <i>dimids</i>[0]
shall be the dimension ID of the most slowly varying
dimension. The maximum possible number of dimensions for a
variable is given by the symbolic constant
<b>NC_MAX_VAR_DIMS</b>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>int <i>dimid</i></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>is the ID of a netCDF dimension. netCDF dimension
ID&rsquo;s are allocated sequentially from the non-negative
integers beginning with 0.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>int <i>ndims</i></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>is either the total number of dimensions in a netCDF
dataset or the rank (i.e. the number of dimensions) of a
netCDF variable. The value shall not be negative or greater
than the symbolic constant <b>NC_MAX_VAR_DIMS</b>.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>int <i>varid</i></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>is the ID of a netCDF variable or (for the
attribute-access functions) the symbolic constant
<b>NC_GLOBAL</b>, which is used to reference global
attributes. netCDF variable ID&rsquo;s are allocated
sequentially from the non-negative integers beginning with
0.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>int* <i>natts</i></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>is the number of global attributes in a netCDF dataset
for the <b>nc_inquire()</b> function or the number of
attributes associated with a netCDF variable for the
<b>nc_varinq()</b> function.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>const size_t <i>index</i>[]</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>specifies the indicial coordinates of the netCDF data
value to be accessed. The indices start at 0; thus, for
example, the first data value of a two-dimensional variable
is (0,0). The size of the vector shall be at least the rank
of the associated netCDF variable and its elements shall
correspond, in order, to the variable&rsquo;s
dimensions.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>const size_t <i>start</i>[]</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>specifies the starting point for accessing a netCDF
variable&rsquo;s data values in terms of the indicial
coordinates of the corner of the array section. The indices
start at 0; thus, the first data value of a variable is (0,
0, ..., 0). The size of the vector shall be at least the
rank of the associated netCDF variable and its elements
shall correspond, in order, to the variable&rsquo;s
dimensions.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>const size_t <i>count</i>[]</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>specifies the number of indices selected along each
dimension of the array section. Thus, to access a single
value, for example, specify <i>count</i> as (1, 1, ..., 1).
Note that, for strided I/O, this argument must be adjusted
to be compatible with the <i>stride</i> and <i>start</i>
arguments so that the interaction of the three does not
attempt to access an invalid data co-ordinate. The elements
of the <i>count</i> vector correspond, in order, to the
variable&rsquo;s dimensions.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>const size_t <i>stride</i>[]</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="21%"></td>
<td width="77%">
<p>specifies the sampling interval along each dimension of
the netCDF variable. The elements of the stride vector
correspond, in order, to the netCDF variable&rsquo;s
dimensions (<i>stride</i>[0]) gives the sampling interval
along the most slowly varying dimension of the netCDF
variable). Sampling intervals are specified in
type-independent units of elements (a value of 1 selects
consecutive elements of the netCDF variable along the
corresponding dimension, a value of 2 selects every other
element, etc.). A <b>NULL</b> stride argument is treated as
(1, 1, ... , 1).</p>
</td>
</table>
<!-- TABS -->
<table width="100%" border=0 rules="none" frame="void"
       cols="4" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="5%">

<p><i>imap</i></p>
</td>
<td width="2%"></td>
<td width="77%">

<p>specifies the mapping between the dimensions of a netCDF
variable and the in-memory structure of the internal data
array. The elements of the index mapping vector correspond,
in order, to the netCDF variable&rsquo;s dimensions
(<i>imap</i>[0] gives the distance between elements of the
internal array corresponding to the most slowly varying
dimension of the netCDF variable). Distances between
elements are specified in type-independent units of elements
(the distance between internal elements that occupy adjacent
memory locations is 1 and not the element&rsquo;s
byte-length as in netCDF 2). A <b>NULL</b> pointer means the
memory-resident values have the same structure as the
associated netCDF variable.</p>
</td>
</table>
<a name="VARIABLE PREFILLING"></a>
<h2>VARIABLE PREFILLING</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>By default, the netCDF interface sets the values of all
newly-defined variables of finite length (i.e. those that do
not have an unlimited, dimension) to the type-dependent
fill-value associated with each variable. This is done when
<b>nc_enddef()</b> is called. The fill-value for a variable
may be changed from the default value by defining the
attribute &lsquo;<b>_FillValue</b>&rsquo; for the variable.
This attribute must have the same type as the variable and
be of length one.</p>
<!-- INDENTATION -->
<p>Variables with an unlimited dimension are also prefilled,
but on an &lsquo;as needed&rsquo; basis. For example, if the
first write of such a variable is to position 5, then
positions 0 through 4 (and no others) would be set to the
fill-value at the same time.</p>
<!-- INDENTATION -->
<p>This default prefilling of data values may be disabled by
or&rsquo;ing the <b>NC_NOFILL</b> flag into the mode
parameter of <b>nc_open()</b> or <b>nc_create()</b>, or, by
calling the function <b>nc_set_fill()</b> with the argument
<b>NC_NOFILL</b>. For variables that do not use the
unlimited dimension, this call must be made before
<b>nc_enddef()</b>. For variables that use the unlimited
dimension, this call may be made at any time.</p>
<!-- INDENTATION -->
<p>One can obtain increased performance of the netCDF
interface by using this feature, but only at the expense of
requiring the application to set every single data value.
The performance enhancing behavior of this function is
dependent on the particulars of the implementation and
dataset format. The flag value controlled by
<b>nc_set_fill()</b> is per netCDF ID, not per variable or
per write. Allowing this to change affects the degree to
which a program can be effectively parallelized. Given all
of this, we state that the use of this feature may not be
available (or even needed) in future releases. Programmers
are cautioned against heavy reliance upon this feature.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_setfill(int</b> <i>ncid</i><b>, int</b>
<i>fillmode</i><b>, int*</b>
<i>old_fillemode</i><b>)</b></p>
<!-- INDENTATION -->
<p>(Corresponds to <b>ncsetfill()</b> in version 2)</p>
<!-- INDENTATION -->
<p>Determines whether or not variable prefilling will be
done (see above). The netCDF dataset shall be writable.
<i>fillmode</i> is either <b>NC_FILL</b> to enable
prefilling (the default) or <b>NC_NOFILL</b> to disable
prefilling. This function returns the previous setting in
<i>old_fillmode</i>.</p>
</td>
</table>
<a name="MPP FUNCTION DESCRIPTIONS"></a>
<h2>MPP FUNCTION DESCRIPTIONS</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Additional functions for use on SGI/Cray MPP machines
(_CRAYMPP). These are used to set and inquire which PE is
the base for MPP for a particular netCDF. These are only
relevant when using the SGI/Cray
&lsquo;&lsquo;global&rsquo;&rsquo; Flexible File I/O layer
and desire to have only a subset of PEs to open the specific
netCDF file. For technical reasons, these functions are
available on all platforms. On a platform other than
SGI/Cray MPP, it is as if only processor available were
processor 0.</p>
<!-- INDENTATION -->
<p>To use this feature, you need to specify a communicator
group and call <b>glio_group_mpi()</b> or
<b>glio_group_shmem()</b> prior to the netCDF
<b>nc_open()</b> and <b>nc_create()</b> calls.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc__create_mp(const char</b> <i>path</i><b>[],
int</b> <i>cmode</i><b>, size_t</b> <i>initialsize</i><b>,
int</b> <i>pe</i><b>, size_t*</b> <i>chunksize</i><b>,
int*</b> <i>ncid</i><b>)</b></p>
<!-- INDENTATION -->
<p>Like <b>nc__create()</b> but allows the base PE to be
set.</p>
<!-- INDENTATION -->
<p>The argument <i>pe</i> sets the base PE at creation time.
In the MPP environment, <b>nc__create()</b> and
<b>nc_create()</b> set the base PE to processor zero by
default.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc__open_mp(const char</b> <i>path</i><b>[],
int</b> <i>mode</i><b>, int</b> <i>pe</i><b>, size_t*</b>
<i>chunksize</i><b>, int*</b> <i>ncid</i><b>)</b></p>
<!-- INDENTATION -->
<p>Like <b>nc__open()</b> but allows the base PE to be set.
The argument <i>pe</i> sets the base PE at creation time. In
the MPP environment, <b>nc__open()</b> and <b>nc_open()</b>
set the base PE to processor zero by default.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_inq_base_pe(int</b> <i>ncid</i><b>, int*</b>
<i>pe</i><b>)</b></p>
<!-- INDENTATION -->
<p>Inquires of the netCDF dataset which PE is being used as
the base for MPP use. This is safe to use at any time.</p>
</td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>int nc_set_base_pe(int</b> <i>ncid</i><b>, int</b>
<i>pe</i><b>)</b></p>
<!-- INDENTATION -->
<p>Resets the base PE for the netCDF dataset. Only perform
this operation when the affected communicator group
synchronizes before and after the call. This operation is
very risky and should only be contemplated under only the
most extreme cases.</p>
</td>
</table>
<a name="ENVIRONMENT VARIABLES"></a>
<h2>ENVIRONMENT VARIABLES</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>NETCDF_FFIOSPEC</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="82%">
<p>Specifies the Flexible File I/O buffers for netCDF I/O
when executing under the UNICOS operating system (the
variable is ignored on other operating systems). An
appropriate specification can greatly increase the
efficiency of netCDF I/O -- to the extent that it can
actually surpass FORTRAN binary I/O. This environment
variable has been made a little more generalized, such that
other FFIO option specifications can now be added. The
default specification is <b>bufa:336:2</b>, unless a current
FFIO specification is in operation, which will be honored.
See UNICOS Flexible File I/O for more information.</p>
</td>
</table>
<a name="MAILING-LISTS"></a>
<h2>MAILING-LISTS</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>Both a mailing list and a digest are available for
discussion of the netCDF interface and announcements about
netCDF bugs, fixes, and enhancements. To begin or change
your subscription to either the mailing-list or the digest,
send one of the following in the body (not the subject line)
of an email message to
&quot;majordomo@unidata.ucar.edu&quot;. Use your email
address in place of <i>jdoe@host.inst.domain</i>.</p>
<!-- INDENTATION -->
<p>To subscribe to the netCDF mailing list:</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p><b>subscribe netcdfgroup</b>
<i>jdoe@host.inst.domain</i></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>To unsubscribe from the netCDF mailing list:</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p><b>unsubscribe netcdfgroup</b>
<i>jdoe@host.inst.domain</i></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>To subscribe to the netCDF digest:</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p><b>subscribe netcdfdigest</b>
<i>jdoe@host.inst.domain</i></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>To unsubscribe from the netCDF digest:</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p><b>unsubscribe netcdfdigest</b>
<i>jdoe@host.inst.domain</i></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>To retrieve the general introductory information for the
mailing list:</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p><b>info netcdfgroup</b></p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p>To get a synopsis of other majordomo commands:</p></td>
</table>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="20%"></td>
<td width="79%">
<p><b>help</b></p></td>
</table>
<a name="SEE ALSO"></a>
<h2>SEE ALSO</h2>
<!-- INDENTATION -->
<table width="100%" border=0 rules="none" frame="void"
       cols="2" cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="89%">
<p><b>ncdump</b>(1), <b>ncgen</b>(1), <b>netcdf</b>(3),
<b>netcdf_f77</b>(3), <b>netcdf_f90</b>(3)).</p>
<!-- INDENTATION -->
<p><i>netCDF User&rsquo;s Guide</i>, published by the
Unidata Program Center, University Corporation for
Atmospheric Research, located in Boulder, Colorado.</p>
</td>
</table>
<hr>
</body>
</html>
